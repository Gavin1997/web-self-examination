(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{411:function(t,e,a){"use strict";a.r(e);var v=a(42),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"面试宝典"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试宝典"}},[t._v("#")]),t._v(" 面试宝典")]),t._v(" "),a("h2",{attrs:{id:"html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[t._v("#")]),t._v(" HTML")]),t._v(" "),a("h3",{attrs:{id:"html5-有哪些新特性-移除了那些元素-如何处理-html5-新标签的浏览器兼容问题-如何区分-html-和-html5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html5-有哪些新特性-移除了那些元素-如何处理-html5-新标签的浏览器兼容问题-如何区分-html-和-html5"}},[t._v("#")]),t._v(" HTML5 有哪些新特性, 移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5")]),t._v(" "),a("ol",[a("li",[t._v("canvas")]),t._v(" "),a("li",[t._v("用于媒介回放的 video 和 audio 元素")]),t._v(" "),a("li",[t._v("本地离线存储。localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除")]),t._v(" "),a("li",[t._v("语意化更好的内容元素，比如 article footer header nav section")]),t._v(" "),a("li",[t._v("位置 API: Geolocation")]),t._v(" "),a("li",[t._v("表单控件，calendar date time email url search")]),t._v(" "),a("li",[t._v("新的技术：web worker(web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket")]),t._v(" "),a("li",[t._v("拖放 API：drag、drop")])]),t._v(" "),a("h3",{attrs:{id:"什么叫优雅降级和渐进增强"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么叫优雅降级和渐进增强"}},[t._v("#")]),t._v(" 什么叫优雅降级和渐进增强？")]),t._v(" "),a("ol",[a("li",[t._v("优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于 IE 独特的盒模型布局问题，针对不同版本的 IE 的 hack 实践过优雅降级了, 为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.")]),t._v(" "),a("li",[t._v("渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能, 向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。")])]),t._v(" "),a("h2",{attrs:{id:"css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" CSS")]),t._v(" "),a("h3",{attrs:{id:"什么是-flex-布局和-grid-布局-分别在什么时候使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-flex-布局和-grid-布局-分别在什么时候使用"}},[t._v("#")]),t._v(" 什么是 flex 布局和 grid 布局？分别在什么时候使用")]),t._v(" "),a("p",[t._v("Flex 布局和 grid 布局都是创建网页布局的好方法。但是，面试官想知道的是两者的主要区别：它们具有哪些功能和更强大灵活的功能？以及应该在何时使用？")]),t._v(" "),a("p",[t._v("Flex 布局是 1D。这意味着使用 flex 布局可以操作行或列，但只能同时操作行和列中的任意一个。在 grid 布局中，您可以同时操作行和列。grid 布局功能非常强大，因为它具有许多强大而有用的特性，这些功能将有助于简化复杂布局的开发和控制。")]),t._v(" "),a("p",[t._v("可以通过 grid 进行大方向的布局，使用 flex 进行具体内容的布局。")]),t._v(" "),a("h3",{attrs:{id:"说明如何维护-css-假设您目前正在负责企业的实际项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说明如何维护-css-假设您目前正在负责企业的实际项目"}},[t._v("#")]),t._v(" 说明如何维护 CSS，假设您目前正在负责企业的实际项目")]),t._v(" "),a("p",[t._v("管理大型项目中的 CSS 可能具有挑战性。一种方法是使用预处理器，例如 SASS 或 LESS。两者都是出色的预处理程序，可以很好地管理 CSS 文件。它们具有函数、变量、嵌套 CSS 等功能。这是避免样式表冲突以及管理大型 CSS 文件的有效方法。")]),t._v(" "),a("h3",{attrs:{id:"_1rem、1em、1vh、1px-各自代表的含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1rem、1em、1vh、1px-各自代表的含义"}},[t._v("#")]),t._v(" 1rem、1em、1vh、1px 各自代表的含义？")]),t._v(" "),a("ul",[a("li",[t._v("rem")])]),t._v(" "),a("p",[t._v("rem 是全部的长度都相对于根元素 "),a("code",[t._v("<html>")]),t._v(" 元素。通常做法是给 html 元素设置一个字体大小，然后其他元素的长度单位就为 rem。")]),t._v(" "),a("ul",[a("li",[t._v("em")])]),t._v(" "),a("p",[t._v("子元素字体大小的 em 是相对于父元素字体大小\n元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size\nvw/vh\n全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。")]),t._v(" "),a("ul",[a("li",[t._v("px")])]),t._v(" "),a("p",[t._v("px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。")]),t._v(" "),a("p",[t._v("一般电脑的分辨率有{1920*1024}等不同的分辨率")]),t._v(" "),a("p",[t._v("1920*1024 前者是屏幕宽度总共有 1920 个像素, 后者则是高度为 1024 个像素\nrem 和 em 都是 CSS 单位。rem 表示 root-em。em 和 rem 之间的区别是，rem 从根元素获取值，而 em 从父元素获取值。这是导致两者完全不同的原因。")]),t._v(" "),a("h3",{attrs:{id:"position-fixed-和-sticky-之间的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#position-fixed-和-sticky-之间的区别"}},[t._v("#")]),t._v(" position fixed 和 sticky 之间的区别")]),t._v(" "),a("p",[t._v('当开发人员要开发复杂的布局时，position 是非常有趣的属性。我们很清楚什么是 fixed，它将把元素"固定"到我们声明的位置。sticky 的基本作用类似于 position：relative，直到元素滚动到特定偏移量以上为止，在这种情况下它将变成 position：fixed，导致元素"粘在"其位置，而不是滚动到视线之外。')]),t._v(" "),a("h3",{attrs:{id:"什么是-critical-css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-critical-css"}},[t._v("#")]),t._v(" 什么是 critical CSS")]),t._v(" "),a("p",[t._v("Critical CSS 是一种提取首屏中 CSS 的技术，以便尽快将内容呈现给用户。这是快速加载网页首屏的好方法。\nCSS 资源的加载情况对浏览器渲染页面的影响很大，这是因为默认情况下浏览器只有在完成 "),a("code",[t._v("<head>")]),t._v(" 部分 CSS 样式的加载、解析之后才会渲染页面。这种渲染方式意味着，如果 CSS 文件很大，那么用户就必须等待很长的时间才能看到渲染结果。针对这一问题，我们将在接下来的内容中讨论一种非常规的解决方案，提高页面的渲染速度，这一方案常被称为 "),a("code",[t._v("critical rendering path")]),t._v(" 。")]),t._v(" "),a("h3",{attrs:{id:"什么是伪元素和伪类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是伪元素和伪类"}},[t._v("#")]),t._v(" 什么是伪元素和伪类")]),t._v(" "),a("p",[t._v("伪元素是样式元素特定部分的方式。例如 "),a("code",[t._v("::first-letter、:: first-line、:: after、:: before")]),t._v(" 等。\n伪类用于定义元素的特殊状态。例如 "),a("code",[t._v(":hover、:focus、:active")]),t._v(" 等。\n按照 CSS3 规范， "),a("code",[t._v("::")]),t._v(" 和 "),a("code",[t._v(":")]),t._v(" 用于区分伪元素和伪类。")]),t._v(" "),a("h3",{attrs:{id:"介绍一下标准的-css-的盒子模型-低版本-ie-的盒子模型有什么不同的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下标准的-css-的盒子模型-低版本-ie-的盒子模型有什么不同的"}},[t._v("#")]),t._v(" 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？")]),t._v(" "),a("p",[t._v("盒子模型有两种：IE 盒子模型(IE5.5 及以下)，W3C 标准盒子模型。")]),t._v(" "),a("p",[t._v("盒子模型(box model)：\n内容(content)、填充(padding)、边框(border)、边界(margin) 。")]),t._v(" "),a("p",[t._v("不同：\nW3C 标准盒子模型的 width 和 height，是 content 的宽高；\nIE 盒模型的 width 和 height，是 content、padding、border 三部分合起来的宽高。\n附加：\noutline（轮廓）绘制在元素框之上，其不占据空间（不影响元素大小和定位）【所以如果轮廓线很粗，会遮住其他内容 demo，不是很懂轮廓的覆盖顺序，它居然可以盖住下一个元素的内容？轮廓本身是另一次元的吗？会覆盖内容，但后一个轮廓会覆盖前一个轮廓】。\n兼容性：IE8 以上。")]),t._v(" "),a("h3",{attrs:{id:"谈一谈-css-重绘与回流-重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈一谈-css-重绘与回流-重排"}},[t._v("#")]),t._v(" 谈一谈 CSS 重绘与回流/重排")]),t._v(" "),a("p",[t._v("会触发重绘或回流/重排的操作")]),t._v(" "),a("ol",[a("li",[t._v("添加、删除元素(回流+重绘)")]),t._v(" "),a("li",[t._v("隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)")]),t._v(" "),a("li",[t._v("移动元素，如改变 top、left 或移动元素到另外 1 个父元素中(重绘+回流)")]),t._v(" "),a("li",[t._v("改变浏览器大小(回流+重绘)")]),t._v(" "),a("li",[t._v("改变浏览器的字体大小(回流+重绘)")]),t._v(" "),a("li",[t._v("改变元素的 padding、border、margin(回流+重绘)")]),t._v(" "),a("li",[t._v("改变浏览器的字体颜色（只重绘，不回流）")]),t._v(" "),a("li",[t._v("改变元素的背景颜色（只重绘，不回流）")])]),t._v(" "),a("h4",{attrs:{id:"需要怎么优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需要怎么优化"}},[t._v("#")]),t._v(" 需要怎么优化？")]),t._v(" "),a("ol",[a("li",[t._v("用 transform 代替 top，left ，margin-top， margin-left... 这些位移属性")]),t._v(" "),a("li",[t._v("opacity 加上 transform: translateZ/3d 这个属性之后便不会发生回流和重绘了")]),t._v(" "),a("li",[t._v("不要使用 js 代码对 dom 元素设置多条样式，选择用一个 className 代替之。")]),t._v(" "),a("li",[t._v("如果确实需要用 js 对 dom 设置多条样式那么可以将这个 dom 先隐藏，然后再对其设置")]),t._v(" "),a("li",[t._v("不要使用 table 布局，因为 table 的每一个行甚至每一个单元格的样式更新都会导致整个 table 重新布局")]),t._v(" "),a("li",[t._v("对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用 video 标签")])]),t._v(" "),a("h2",{attrs:{id:"js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[t._v("#")]),t._v(" JS")]),t._v(" "),a("h3",{attrs:{id:"谈谈用户从输入-url-到页面渲染完成发生了什么过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈用户从输入-url-到页面渲染完成发生了什么过程"}},[t._v("#")]),t._v(" 谈谈用户从输入 url 到页面渲染完成发生了什么过程")]),t._v(" "),a("ol",[a("li",[t._v("浏览器的地址栏输入 URL 并按下回车。")]),t._v(" "),a("li",[t._v("浏览器查找当前 URL 的 DNS 缓存记录。")]),t._v(" "),a("li",[t._v("DNS 解析 URL 对应的 IP。")]),t._v(" "),a("li",[t._v("根据 IP 建立 TCP 连接（三次握手）。")]),t._v(" "),a("li",[t._v("HTTP 发起请求。")]),t._v(" "),a("li",[t._v("服务器处理请求，浏览器接收 HTTP 响应。")]),t._v(" "),a("li",[t._v("渲染页面，构建 DOM 树。")]),t._v(" "),a("li",[t._v("关闭 TCP 连接（四次挥手）")])]),t._v(" "),a("h3",{attrs:{id:"谈谈深拷贝和浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈深拷贝和浅拷贝"}},[t._v("#")]),t._v(" 谈谈深拷贝和浅拷贝")]),t._v(" "),a("p",[t._v("浅拷贝：浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。\n深拷贝：深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。")]),t._v(" "),a("h3",{attrs:{id:"dom-事件模型-事件流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-事件模型-事件流"}},[t._v("#")]),t._v(" DOM 事件模型 事件流")]),t._v(" "),a("p",[t._v("事件模型分为：捕获和冒泡\n事件流：\n（1）捕获阶段：事件从 window 对象自上而下向目标节点传播的阶段；\n（2）目标阶段：真正的目标节点正在处理事件的阶段；\n（3）冒泡阶段：事件从目标节点自下而上向 window 对象传播的阶段。\n事件委托（代理）\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）\n优点：")]),t._v(" "),a("ol",[a("li",[t._v("减少内存消耗，提高性能不需要为每一个子元素绑定事件")]),t._v(" "),a("li",[t._v("动态绑定事件")])]),t._v(" "),a("h3",{attrs:{id:"如何中断-ajax-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何中断-ajax-请求"}},[t._v("#")]),t._v(" 如何中断 ajax 请求？")]),t._v(" "),a("p",[t._v("一种是设置超时时间让 ajax 自动断开，另一种是手动停止 ajax 请求，其核心是调用 XML 对象的 abort 方法， "),a("code",[t._v("ajax.abort()")])]),t._v(" "),a("h3",{attrs:{id:"跨域是什么原因引起-怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域是什么原因引起-怎么解决"}},[t._v("#")]),t._v(" 跨域是什么原因引起？怎么解决？")]),t._v(" "),a("p",[t._v("跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。")]),t._v(" "),a("ol",[a("li",[t._v("jsonp 函数")])]),t._v(" "),a("p",[t._v("在 HTML DOM 中, script 标签本身就可以访问其它域的资源，不受浏览器同源策略的限制，可以通过在页面动态创建 script 标签。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" script "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"script"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nscript"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("src "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"http://aa.xx.com/js/*.js"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("iframe 实现跨域")])]),t._v(" "),a("p",[t._v("基于 iframe 实现的跨域要求两个域具有 aa.xx.com, bb.xx.com 这种特点，也就是两个页面必须属于同一个顶级基础域（例如都是 xxx.com，或是 xxx.com.cn），使用同一协议（例如都是 http）和同一端口（例如都是 80），这样在两个页面中同时添加 document.domain，就可以实现父页面调用子页面的函数")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("跨域资源共享（CORS）")])]),t._v(" "),a("p",[t._v("服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("使用 HTML5 的 window.postMessage 方法跨域")])]),t._v(" "),a("p",[t._v("window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。目前 IE8+、FireFox、Chrome、Opera 等浏览器都已经支持 window.postMessage 方法。")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("nginx 反向代理")])]),t._v(" "),a("h3",{attrs:{id:"谈谈你对闭包的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对闭包的理解"}},[t._v("#")]),t._v(" 谈谈你对闭包的理解")]),t._v(" "),a("p",[t._v("函数声明的时候，会生成一个独立的作用域，同一作用域的对象可以互相访问，作用域呈层级包含状态，形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；另外子作用域会使用最近的父作用域的对象")]),t._v(" "),a("h3",{attrs:{id:"谈谈原型链继承的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈原型链继承的理解"}},[t._v("#")]),t._v(" 谈谈原型链继承的理解")]),t._v(" "),a("p",[t._v("什么是原型链：只要是对象就有原型, 并且原型也是对象, 因此只要定义了一个对象, 那么就可以找到他的原型, 如此反复, 就可以构成一个对象的序列, 这个结构就被称为原型链\n所有的实例有一个内部指针(prototype)，指向它的原型对象，并且可以访问原型对象上的所有属性和方法。")]),t._v(" "),a("h3",{attrs:{id:"说说构造函数中原型方法-静态方法-实列方法的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说构造函数中原型方法-静态方法-实列方法的区别"}},[t._v("#")]),t._v(" 说说构造函数中原型方法, 静态方法, 实列方法的区别")]),t._v(" "),a("p",[t._v("简而言之，实例方法就是只有实例可以调用，静态方法只有构造函数可以调用，原型方法是实例和构造函数都可以调用，是共享的方法。")]),t._v(" "),a("p",[t._v("像 Promise.all 和 Promise.race 这些就是静态方法，Promise.prototype.then 这些就是原型方法，new 出来的实例可以调用")]),t._v(" "),a("h3",{attrs:{id:"谈谈-tostring-和-string-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈-tostring-和-string-的区别"}},[t._v("#")]),t._v(" 谈谈 toString 和 String 的区别？")]),t._v(" "),a("p",[t._v("toString()方法；数值、字符串、对象、布尔；都有 toString 方法；这个方法唯一能做的就是返回相应的字符串；其中 null 和 undefined 没有 toString()方法；\nString()属于强制转换， null 转换的结果为 null；undefined 转换的结果为 undefined；其余的如果有 toString()方法，即调用该方法，返回相应的结果；")]),t._v(" "),a("h2",{attrs:{id:"框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#框架"}},[t._v("#")]),t._v(" 框架")]),t._v(" "),a("h3",{attrs:{id:"mvvm-和-mvc-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-和-mvc-的区别"}},[t._v("#")]),t._v(" MVVM 和 MVC 的区别")]),t._v(" "),a("p",[t._v("MVC：MVC 模式可以这样理解，将 html 看成 view; js 看成 controller，处理用户与应用的交互，响应对 view 的操作（对事件的监听），调用 Model 对数据进行操作，完成 model 与 view 的同步（根据 model 的改变，通过选择器对 view 进行操作）; 将 js 的 ajax 当做 Model，从服务器获取数据，MVC 是单向的。\nMVVM：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变，MVVM 是双向的。")]),t._v(" "),a("h3",{attrs:{id:"nexttick-知道吗-实现原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-知道吗-实现原理是什么"}},[t._v("#")]),t._v(" nextTick 知道吗，实现原理是什么")]),t._v(" "),a("p",[t._v("在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用")]),t._v(" "),a("ul",[a("li",[t._v("Promise")]),t._v(" "),a("li",[t._v("MutationObserver")]),t._v(" "),a("li",[t._v("setImmediate")])]),t._v(" "),a("p",[t._v("如果以上都不行则采用 setTimeout\n定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。")]),t._v(" "),a("h3",{attrs:{id:"vue-router-的路由模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-的路由模式"}},[t._v("#")]),t._v(" vue-router 的路由模式?")]),t._v(" "),a("h4",{attrs:{id:"hash、history"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash、history"}},[t._v("#")]),t._v(" hash、history")]),t._v(" "),a("ol",[a("li",[t._v("早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理也很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 "),a("code",[t._v("location.hash")]),t._v(" 的值为 "),a("code",[t._v("'#search'")])])]),t._v(" "),a("p",[t._v("此外，hash 也存在下面几个特性：\nURL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送。\nhash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换。\n我们可以使用 hashchange 事件来监听 hash 的变化。\n我们可以通过两种方式触发 hash 变化，一种是通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 就会发生改变，也就会触发 hashchange 事件了：\n"),a("code",[t._v('<a href="#search">search</a>')])]),t._v(" "),a("p",[t._v("复制代码还有一种方式就是直接使用 JavaScript 来对 "),a("code",[t._v("loaction.hash")]),t._v(" 进行赋值，从而改变 URL，触发 "),a("code",[t._v("hashchange")]),t._v(" 事件：\n"),a("code",[t._v('location.hash="#search"')])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("前面的 hash 虽然也很不错，但使用时都需要加上 #，并不是很美观。因此到了 HTML5，又提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pushState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nwindow"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("replaceState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("复制代码此外，history 存在下面几个特性：")]),t._v(" "),a("p",[a("code",[t._v("pushState")]),t._v(" 和 "),a("code",[t._v("repalceState")]),t._v(" 的标题（title）：一般浏览器会忽略，最好传入 null ；\n我们可以使用 popstate  事件来监听 url 的变化；\n"),a("code",[t._v("history.pushState()")]),t._v(" 或 "),a("code",[t._v("history.replaceState()")]),t._v(" 不会触发 popstate 事件，这时我们需要手动触发页面渲染；")]),t._v(" "),a("h3",{attrs:{id:"route和-router-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#route和-router-的区别"}},[t._v("#")]),t._v(" $route和$router 的区别")]),t._v(" "),a("p",[t._v("$router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。\n$route 对象表示当前的路由信息，包含了当前 URL 解析得到的信息")]),t._v(" "),a("h3",{attrs:{id:"target、currenttarget-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#target、currenttarget-的区别"}},[t._v("#")]),t._v(" target、currentTarget 的区别？")]),t._v(" "),a("p",[t._v("currentTarget 当前所绑定事件的元素")]),t._v(" "),a("p",[t._v("target 当前被点击的元素")]),t._v(" "),a("h3",{attrs:{id:"vue-中-key-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中-key-的作用"}},[t._v("#")]),t._v(" vue 中 key 的作用")]),t._v(" "),a("p",[t._v("强制替换元素，从而可以触发组件的生命周期钩子或者触发过渡。因为当 key 改变时，Vue 认为一个新的元素产生了，从而会新插入一个元素来替换掉原有的元素。\n"),a("code",[t._v('<transition> <span :key="text">'+t._s(t.text)+"</span> </transition>")]),t._v(" 、")]),t._v(" "),a("p",[t._v("--这里如果 text 发生改变，整个 "),a("code",[t._v("<span>")]),t._v(" 元素会发生更新，因为当 text 改变时，这个元素的 key 属性就发生了改变，在渲染更新时，Vue 会认为这里新产生了一个元素，而老的元素由于 key 不存在了，所以会被删除，从而触发了过渡。\n同理，key 属性被用在组件上时，当 key 改变时会引起新组件的创建和原有组")]),t._v(" "),a("h3",{attrs:{id:"v-if-和-v-for-谁的优先级高-如何同时使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-for-谁的优先级高-如何同时使用"}},[t._v("#")]),t._v(" v-if 和 v-for 谁的优先级高？如何同时使用？")]),t._v(" "),a("p",[t._v("首先：永远不要把 v-if 和 v-for 同时用在同一个元素上。")]),t._v(" "),a("p",[t._v("其次：当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级")]),t._v(" "),a("p",[t._v("将 users 替换为一个计算属性 "),a("code",[t._v("(比如 activeUsers)")]),t._v(" ，让其返回过滤后的列表")]),t._v(" "),a("h3",{attrs:{id:"vue-中组件生命周期调用顺序说一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中组件生命周期调用顺序说一下"}},[t._v("#")]),t._v(" Vue 中组件生命周期调用顺序说一下")]),t._v(" "),a("p",[t._v("组件的调用顺序都是先父后子, 渲染完成的顺序是先子后父。")]),t._v(" "),a("p",[t._v("组件的销毁操作是先父后子，销毁完成的顺序是先子后父。")]),t._v(" "),a("ul",[a("li",[t._v("加载渲染过程")])]),t._v(" "),a("p",[t._v("父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount- >子 mounted->父 mounted")]),t._v(" "),a("ul",[a("li",[t._v("子组件更新过程")])]),t._v(" "),a("p",[t._v("父 beforeUpdate->子 beforeUpdate->子 updated->父 updated")]),t._v(" "),a("ul",[a("li",[t._v("父组件更新过程")])]),t._v(" "),a("p",[t._v("父 beforeUpdate -> 父 updated")]),t._v(" "),a("ul",[a("li",[t._v("销毁过程")])]),t._v(" "),a("p",[t._v("父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed")]),t._v(" "),a("h3",{attrs:{id:"vue2-x-组件通信有哪些方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x-组件通信有哪些方式"}},[t._v("#")]),t._v(" Vue2.x 组件通信有哪些方式？")]),t._v(" "),a("ul",[a("li",[t._v("父子组件通信")])]),t._v(" "),a("p",[t._v("父->子 props，子->父 $on、$emit")]),t._v(" "),a("p",[t._v("获取父子组件实例 $parent、$children")]),t._v(" "),a("p",[t._v("Ref 获取实例的方式调用组件的属性或者方法")]),t._v(" "),a("p",[t._v("Provide、inject 官方不推荐使用，但是写组件库时很常用")]),t._v(" "),a("ul",[a("li",[t._v("兄弟组件通信")])]),t._v(" "),a("p",[t._v("Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue")]),t._v(" "),a("p",[t._v("Vuex")]),t._v(" "),a("ul",[a("li",[t._v("跨级组件通信")])]),t._v(" "),a("p",[t._v("Vuex")]),t._v(" "),a("p",[t._v("$attrs、$listeners")]),t._v(" "),a("p",[t._v("Provide、inject")]),t._v(" "),a("h3",{attrs:{id:"vue-中常用的修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中常用的修饰符"}},[t._v("#")]),t._v(" vue 中常用的修饰符")]),t._v(" "),a("p",[t._v(".stop //组织单击事件冒泡\n.prevent //提交事件不再重新加载页面\n.capture //添加事件侦听器时使用事件捕获模式\n.self //只当事件在该元素本身时触发回调（在其子元素上不触发）\n.once //只触发一次事件")]),t._v(" "),a("h3",{attrs:{id:"对-keep-alive-的了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对-keep-alive-的了解"}},[t._v("#")]),t._v(" 对 keep-alive 的了解")]),t._v(" "),a("p",[t._v("keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。")]),t._v(" "),a("p",[t._v("常用的两个属性 include/exclude，允许组件有条件的进行缓存。")]),t._v(" "),a("p",[t._v("两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。\n通过设置了 keep-alive，可以简单理解为从页面 1 跳转到页面 2 后，然后后退到页面 1，只会加载缓存中之前已经渲染好的页面 1，而不会再次重新加载页面 1，及不会再触发页面一种的 created 等类似的钩子函数，除非自己重新刷新该页面")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("activated")]),t._v(" ： 页面第一次进入的时候，钩子触发的顺序是 created->mounted->activated")]),t._v(" "),a("li",[a("code",[t._v("deactivated")]),t._v(" : 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated")])]),t._v(" "),a("h3",{attrs:{id:"vuex-中的成员-对应的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中的成员-对应的作用"}},[t._v("#")]),t._v(" vuex 中的成员？对应的作用")]),t._v(" "),a("p",[t._v("state => 基本数据\ngetters => 从基本数据派生的数据\nmutations => 提交更改数据的方法，同步！\nactions => 像一个装饰器，包裹 mutations，使之可以异步。\nmodules => 模块化 Vuex")]),t._v(" "),a("h3",{attrs:{id:"vue-模版编译原理知道吗-能简单说一下吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-模版编译原理知道吗-能简单说一下吗"}},[t._v("#")]),t._v(" Vue 模版编译原理知道吗，能简单说一下吗")]),t._v(" "),a("p",[t._v("简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：")]),t._v(" "),a("ul",[a("li",[t._v("生成 AST 树")]),t._v(" "),a("li",[t._v("优化")]),t._v(" "),a("li",[t._v("codegen")])]),t._v(" "),a("p",[t._v("首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。")]),t._v(" "),a("p",[t._v("Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。")]),t._v(" "),a("p",[t._v("编译的最后一步是将优化后的 AST 树转换为可执行的代码。")]),t._v(" "),a("h3",{attrs:{id:"你都做过哪些-vue-的性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你都做过哪些-vue-的性能优化"}},[t._v("#")]),t._v(" 你都做过哪些 Vue 的性能优化")]),t._v(" "),a("ul",[a("li",[t._v("尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher")]),t._v(" "),a("li",[t._v("v-if 和 v-for 不能连用")]),t._v(" "),a("li",[t._v("如果需要使用 v-for 给每项元素绑定事件时使用事件代理")]),t._v(" "),a("li",[t._v("SPA 页面采用 keep-alive 缓存组件")]),t._v(" "),a("li",[t._v("在更多的情况下，使用 v-if 替代 v-show")]),t._v(" "),a("li",[t._v("key 保证唯一")]),t._v(" "),a("li",[t._v("使用路由懒加载、异步组件")]),t._v(" "),a("li",[t._v("防抖、节流")]),t._v(" "),a("li",[t._v("第三方模块按需导入")]),t._v(" "),a("li",[t._v("长列表滚动到可视区域动态加载")]),t._v(" "),a("li",[t._v("图片懒加载")])]),t._v(" "),a("h2",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),a("h3",{attrs:{id:"react-中-keys-的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-中-keys-的作用是什么"}},[t._v("#")]),t._v(" React 中 keys 的作用是什么？")]),t._v(" "),a("p",[t._v("Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。")]),t._v(" "),a("p",[t._v("在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性")]),t._v(" "),a("h3",{attrs:{id:"react-生命周期函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期函数"}},[t._v("#")]),t._v(" react 生命周期函数")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("初始化阶段：")]),t._v(" "),a("ul",[a("li",[t._v("getDefaultProps: 获取实例的默认属性")]),t._v(" "),a("li",[t._v("getInitialState: 获取每个实例的初始化状态")]),t._v(" "),a("li",[t._v("componentWillMount：组件即将被装载、渲染到页面上")]),t._v(" "),a("li",[t._v("render: 组件在这里生成虚拟的 DOM 节点")]),t._v(" "),a("li",[t._v("componentDidMount: 组件真正在被装载之后")])])]),t._v(" "),a("li",[a("p",[t._v("运行中状态：")]),t._v(" "),a("ul",[a("li",[t._v("componentWillReceiveProps: 组件将要接收到属性的时候调用")]),t._v(" "),a("li",[t._v("shouldComponentUpdate: 组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）")]),t._v(" "),a("li",[t._v("componentWillUpdate: 组件即将更新不能修改属性和状态")]),t._v(" "),a("li",[t._v("render: 组件重新描绘")]),t._v(" "),a("li",[t._v("componentDidUpdate: 组件已经更新")])])]),t._v(" "),a("li",[a("p",[t._v("销毁阶段：")]),t._v(" "),a("p",[t._v("componentWillUnmount: 组件即将销毁")])])]),t._v(" "),a("h3",{attrs:{id:"shouldcomponentupdate-是做什么的-react-性能优化是哪个周期函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-是做什么的-react-性能优化是哪个周期函数"}},[t._v("#")]),t._v(" shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）")]),t._v(" "),a("p",[t._v("shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。")]),t._v(" "),a("h3",{attrs:{id:"为什么虚拟-dom-会提高性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么虚拟-dom-会提高性能"}},[t._v("#")]),t._v(" 为什么虚拟 dom 会提高性能?")]),t._v(" "),a("p",[t._v("虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。")]),t._v(" "),a("p",[t._v("用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。")]),t._v(" "),a("h3",{attrs:{id:"react-diff-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-原理"}},[t._v("#")]),t._v(" react diff 原理")]),t._v(" "),a("ul",[a("li",[t._v("把树形结构按照层级分解，只比较同级元素。")]),t._v(" "),a("li",[t._v("给列表结构的每个单元添加唯一的 key 属性，方便比较。")]),t._v(" "),a("li",[t._v("React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）")]),t._v(" "),a("li",[t._v("合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.")]),t._v(" "),a("li",[t._v("选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。")])]),t._v(" "),a("h2",{attrs:{id:"工作流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作流"}},[t._v("#")]),t._v(" 工作流")]),t._v(" "),a("h3",{attrs:{id:"谈谈前端性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈前端性能优化"}},[t._v("#")]),t._v(" 谈谈前端性能优化")]),t._v(" "),a("ol",[a("li",[t._v("减少 HTTP 请求：合并文件、CSS 精灵、inline Image")]),t._v(" "),a("li",[t._v("减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询")]),t._v(" "),a("li",[t._v("避免重定向：多余的中间访问")]),t._v(" "),a("li",[t._v("使 Ajax 可缓存")]),t._v(" "),a("li",[t._v("非必须组件延迟加载,未来所需组件预加载")]),t._v(" "),a("li",[t._v("减少 DOM 元素数量")]),t._v(" "),a("li",[t._v("将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量")]),t._v(" "),a("li",[t._v("减少 iframe 数量")])]),t._v(" "),a("h2",{attrs:{id:"restapi-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restapi-请求"}},[t._v("#")]),t._v(" restAPI 请求")]),t._v(" "),a("h3",{attrs:{id:"什么是-options-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-options-请求"}},[t._v("#")]),t._v(" 什么是 options 请求")]),t._v(" "),a("p",[t._v("HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。\n简单来说，就是可以用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法。")]),t._v(" "),a("p",[t._v('在前端中我们一般不会主动发起这个请求，但是往往你可以看到浏览器中相同的请求发起了 2 次\n其实，这是因为在跨域的情况下，在浏览器发起"复杂请求"时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。')]),t._v(" "),a("h4",{attrs:{id:"简单请求与复杂请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单请求与复杂请求"}},[t._v("#")]),t._v(" 简单请求与复杂请求")]),t._v(" "),a("p",[t._v('某些请求不会触发 CORS 预检请求，这样的请求一般称为"简单请求", 而会触发预检的请求则称为"复杂请求"。')]),t._v(" "),a("h5",{attrs:{id:"简单请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单请求"}},[t._v("#")]),t._v(" 简单请求")]),t._v(" "),a("ul",[a("li",[t._v("请求方法为 GET、HEAD、POST 时发的请求")]),t._v(" "),a("li",[t._v("人为设置了规范集合之内的首部字段，如 Accept/Accept-Language/Content-Language/- Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width")]),t._v(" "),a("li",[t._v("Content-Type 的值仅限于下列三者之一, 即 application/x-www-form-urlencoded、multipart/- form-data、text/plain")]),t._v(" "),a("li",[t._v("请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；")]),t._v(" "),a("li",[t._v("请求中没有使用 ReadableStream 对象。")])]),t._v(" "),a("h6",{attrs:{id:"复杂请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂请求"}},[t._v("#")]),t._v(" 复杂请求")]),t._v(" "),a("ul",[a("li",[t._v("使用了下面任一 HTTP 方法，PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH")]),t._v(" "),a("li",[t._v("人为设置了以下集合之外首部字段，即简单请求外的字段")]),t._v(" "),a("li",[t._v("Content-Type 的值不属于下列之一，即 application/x-www-form-urlencoded、multipart/form-data、text/plain")])]),t._v(" "),a("p",[a("code",[t._v("options 关键的请求字段")])]),t._v(" "),a("p",[a("strong",[t._v("request header 的关键字段")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("关键字段")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Access-Control-Request-Method")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("告知服务器，实际请求将使用 POST 方法")])]),t._v(" "),a("tr",[a("td",[t._v("Access-Control-Request-Headers")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("告知服务器，实际请求将携带的自定义请求首部字段")])])])]),t._v(" "),a("p",[t._v("如：\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type")]),t._v(" "),a("p",[a("strong",[t._v("response header 的关键字段")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("关键字段")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Access-Control-Allow-Methods")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("表明服务器允许客户端使用什么方法发起请求")])]),t._v(" "),a("tr",[a("td",[t._v("Access-Control-Allow-Origin")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("允许跨域请求的域名，如果要允许所有域名则设置为 *")])]),t._v(" "),a("tr",[a("td",[t._v("Access-Control-Request-Headers")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将实际请求所携带的首部字段告诉服务器")])]),t._v(" "),a("tr",[a("td",[t._v("Access-Control-Max-Age")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("指定了预检请求的结果能够被缓存多久")])])])]),t._v(" "),a("h4",{attrs:{id:"options-请求优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#options-请求优化"}},[t._v("#")]),t._v(" Options 请求优化")]),t._v(" "),a("p",[t._v("当我们发起跨域请求时，如果是简单请求，那么我们只会发出一次请求，但是如果是复杂请求则先发出 options 请求，用于确认目标资源是否支持跨域，然后浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。")]),t._v(" "),a("p",[t._v("由此可见，当触发预检时，跨域请求便会发送 2 次请求，既增加了请求数，也延迟了请求真正发起的时间，严重影响性能。")]),t._v(" "),a("p",[t._v("所以，我们可以优化 Options 请求，主要有 2 种方法。")]),t._v(" "),a("ol",[a("li",[t._v("转为简单请求，如用 JSONP 做跨域请求")]),t._v(" "),a("li",[t._v("对 options 请求进行缓存，服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）")])]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。")]),t._v(" "),a("h3",{attrs:{id:"get-和-post-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[t._v("#")]),t._v(" get 和 POST 的区别")]),t._v(" "),a("p",[t._v('get 用来获取数据，post 用来提交数据\nget 参数有长度限制（受限于 url 长度，具体的数值取决于浏览器和服务器的限制，最长 2048 字节），而 post 无限制。\nget 请求的数据会附加在 url 之 ，以 " ？ "分割 url 和传输数据，多个参数用 "&"连接，而 post 请求会把请求的数据放在 http 请求体中。\nget 是明文传输，post 是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。\nget 请求会保存在浏览器历史记录中，还可能保存在 web 服务器的日志中\n首先 get 和 post 在本质上都是 tcp 链接，但由于 http 协议和浏览器或者服务器的限制，从而使它们在应用过程中产生了差别，但是它们中还有一个较大的区别：get 在请求时发送一个数据包，会将 header 和 data 一起发送过去，而 post 会产生两个数据包先发送 header，服务器返回 100，然后在发送 data，服务器返回 200')]),t._v(" "),a("h2",{attrs:{id:"工具的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工具的使用"}},[t._v("#")]),t._v(" 工具的使用")]),t._v(" "),a("h4",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[t._v("#")]),t._v(" webpack")]),t._v(" "),a("h5",{attrs:{id:"有哪些常见的-loader-你用过哪些-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的-loader-你用过哪些-loader"}},[t._v("#")]),t._v(" 有哪些常见的 Loader？你用过哪些 Loader？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("raw-loader：加载文件原始内容（utf-8）\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)\nurl-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)\nsource-map-loader：加载额外的 Source Map 文件，以方便断点调试\nsvg-inline-loader：将压缩后的 SVG 内容注入代码中\nimage-loader：加载并且压缩图片文件\njson-loader 加载 JSON 文件（默认包含）\nhandlebars-loader: 将 Handlebars 模版编译成函数并返回\nbabel-loader：把 ES6 转换成 ES5\nts-loader: 将 TypeScript 转换成 JavaScript\nawesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader\nsass-loader：将SCSS/SASS代码转换成CSS\ncss-loader：加载 CSS，支持模块化、压缩、文件导入等特性\nstyle-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS\npostcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀\neslint-loader：通过 ESLint 检查 JavaScript 代码\ntslint-loader：通过 TSLint检查 TypeScript 代码\nmocha-loader：加载 Mocha 测试用例的代码\ncoverjs-loader：计算测试的覆盖率\nvue-loader：加载 Vue.js 单文件组件\ni18n-loader: 国际化\ncache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里\n")])])]),a("h5",{attrs:{id:"有哪些常见的-plugin-你用过哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的-plugin-你用过哪些"}},[t._v("#")]),t._v(" 有哪些常见的 Plugin？你用过哪些")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("Plugindefine-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)\nignore-plugin：忽略部分文件\nhtml-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)\nweb-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用\nuglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)\nterser-webpack-plugin: 支持压缩 ES6 (Webpack4)\nwebpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度\nmini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)\nserviceworker-webpack-plugin：为网页应用增加离线缓存功能\nclean-webpack-plugin: 目录清理\nModuleConcatenationPlugin: 开启 Scope Hoisting\nspeed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)\nwebpack-bundle-analyz\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);
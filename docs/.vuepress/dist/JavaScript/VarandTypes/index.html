<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>变量和类型 | 前端自省清单</title>
    <meta name="description" content="全面、深入解析MDN推荐使用的JavaScript API">
    
    
    <link rel="preload" href="/web-self-examination/assets/css/0.styles.27befe48.css" as="style"><link rel="preload" href="/web-self-examination/assets/js/app.819c3246.js" as="script"><link rel="preload" href="/web-self-examination/assets/js/2.ee1b66a9.js" as="script"><link rel="preload" href="/web-self-examination/assets/js/30.55b5afbd.js" as="script"><link rel="prefetch" href="/web-self-examination/assets/js/10.64effff2.js"><link rel="prefetch" href="/web-self-examination/assets/js/11.7464fd7b.js"><link rel="prefetch" href="/web-self-examination/assets/js/12.0c0245d2.js"><link rel="prefetch" href="/web-self-examination/assets/js/13.a6973ead.js"><link rel="prefetch" href="/web-self-examination/assets/js/14.1333dc2e.js"><link rel="prefetch" href="/web-self-examination/assets/js/15.ac176978.js"><link rel="prefetch" href="/web-self-examination/assets/js/16.9cc486a2.js"><link rel="prefetch" href="/web-self-examination/assets/js/17.0b2c0605.js"><link rel="prefetch" href="/web-self-examination/assets/js/18.0cb3cbea.js"><link rel="prefetch" href="/web-self-examination/assets/js/19.08011727.js"><link rel="prefetch" href="/web-self-examination/assets/js/20.84bd5268.js"><link rel="prefetch" href="/web-self-examination/assets/js/21.10ac1404.js"><link rel="prefetch" href="/web-self-examination/assets/js/22.33dd7c8c.js"><link rel="prefetch" href="/web-self-examination/assets/js/23.c94f238d.js"><link rel="prefetch" href="/web-self-examination/assets/js/24.404b9f54.js"><link rel="prefetch" href="/web-self-examination/assets/js/25.c71eb4ef.js"><link rel="prefetch" href="/web-self-examination/assets/js/26.10862b39.js"><link rel="prefetch" href="/web-self-examination/assets/js/27.10c5c9d7.js"><link rel="prefetch" href="/web-self-examination/assets/js/28.d7746e16.js"><link rel="prefetch" href="/web-self-examination/assets/js/29.bcb48415.js"><link rel="prefetch" href="/web-self-examination/assets/js/3.745d8426.js"><link rel="prefetch" href="/web-self-examination/assets/js/31.4b685252.js"><link rel="prefetch" href="/web-self-examination/assets/js/32.15d9b0b3.js"><link rel="prefetch" href="/web-self-examination/assets/js/33.9d58d15c.js"><link rel="prefetch" href="/web-self-examination/assets/js/34.70f55b66.js"><link rel="prefetch" href="/web-self-examination/assets/js/35.0a15d412.js"><link rel="prefetch" href="/web-self-examination/assets/js/36.8f965948.js"><link rel="prefetch" href="/web-self-examination/assets/js/37.ee8be222.js"><link rel="prefetch" href="/web-self-examination/assets/js/38.4c78b365.js"><link rel="prefetch" href="/web-self-examination/assets/js/39.c2eab45d.js"><link rel="prefetch" href="/web-self-examination/assets/js/4.3547d142.js"><link rel="prefetch" href="/web-self-examination/assets/js/40.f32c2fa0.js"><link rel="prefetch" href="/web-self-examination/assets/js/41.4aa0d1b7.js"><link rel="prefetch" href="/web-self-examination/assets/js/42.582a78fe.js"><link rel="prefetch" href="/web-self-examination/assets/js/43.4205e018.js"><link rel="prefetch" href="/web-self-examination/assets/js/44.2742d4bc.js"><link rel="prefetch" href="/web-self-examination/assets/js/45.f82bea25.js"><link rel="prefetch" href="/web-self-examination/assets/js/46.a27af051.js"><link rel="prefetch" href="/web-self-examination/assets/js/47.3e5d1f5d.js"><link rel="prefetch" href="/web-self-examination/assets/js/48.a20aa291.js"><link rel="prefetch" href="/web-self-examination/assets/js/49.d0709077.js"><link rel="prefetch" href="/web-self-examination/assets/js/5.a5f8f5ef.js"><link rel="prefetch" href="/web-self-examination/assets/js/50.d6392327.js"><link rel="prefetch" href="/web-self-examination/assets/js/51.507014bf.js"><link rel="prefetch" href="/web-self-examination/assets/js/52.7dae4f55.js"><link rel="prefetch" href="/web-self-examination/assets/js/53.f9f065eb.js"><link rel="prefetch" href="/web-self-examination/assets/js/54.b39cf1b3.js"><link rel="prefetch" href="/web-self-examination/assets/js/6.a678307a.js"><link rel="prefetch" href="/web-self-examination/assets/js/7.5ae52c37.js"><link rel="prefetch" href="/web-self-examination/assets/js/8.185400b0.js"><link rel="prefetch" href="/web-self-examination/assets/js/9.e0ad901f.js">
    <link rel="stylesheet" href="/web-self-examination/assets/css/0.styles.27befe48.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/web-self-examination/" class="home-link router-link-active"><!----> <span class="site-name">前端自省清单</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web-self-examination/JavaScript/" class="nav-link router-link-active">JavaScript</a></div><div class="nav-item"><a href="/web-self-examination/HTML/" class="nav-link">HTML</a></div><div class="nav-item"><a href="/web-self-examination/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="http://www.gavin88.top:5800" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Gavin1997/vuepress_web.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web-self-examination/JavaScript/" class="nav-link router-link-active">JavaScript</a></div><div class="nav-item"><a href="/web-self-examination/HTML/" class="nav-link">HTML</a></div><div class="nav-item"><a href="/web-self-examination/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="http://www.gavin88.top:5800" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Gavin1997/vuepress_web.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web-self-examination/JavaScript/VarandTypes/" class="active sidebar-link">变量和类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#js-规定了几种语言类型" class="sidebar-link">js 规定了几种语言类型</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#js-对象的底层数据结构是什么" class="sidebar-link">js 对象的底层数据结构是什么</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#symbol-类型在实际开发中的应用" class="sidebar-link">Symbol 类型在实际开发中的应用</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#变量在内存中的存储形式" class="sidebar-link">变量在内存中的存储形式</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#null-和-undefined-的区别" class="sidebar-link">null 和 undefined 的区别</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#三种判断-javascript-数据类型的方式" class="sidebar-link">三种判断 JavaScript 数据类型的方式</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#出现小数精度丢失的原因" class="sidebar-link">出现小数精度丢失的原因</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#可能发生隐式类型转换的场景以及转换原则" class="sidebar-link">可能发生隐式类型转换的场景以及转换原则</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/VarandTypes/#理解值类型和引用类型" class="sidebar-link">理解值类型和引用类型</a></li></ul></li><li><a href="/web-self-examination/JavaScript/ProtoAndChain/" class="sidebar-link">原型和原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#理解原型设计模式以及-javascript-中的原型规则" class="sidebar-link">理解原型设计模式以及 JavaScript 中的原型规则</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#instanceof-的底层实现原理，手动实现一个-instanceof" class="sidebar-link">instanceof 的底层实现原理，手动实现一个 instanceof</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#实现继承的几种方式以及他们的优缺点" class="sidebar-link">实现继承的几种方式以及他们的优缺点</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#apply-call-bind-自我实现" class="sidebar-link">apply/call/bind 自我实现</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#至少说出一种开源项目-如-node-中应用原型继承的案例" class="sidebar-link">至少说出一种开源项目(如 Node)中应用原型继承的案例</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#可以描述-new-一个对象的详细过程，手动实现一个-new-操作符" class="sidebar-link">可以描述 new 一个对象的详细过程，手动实现一个 new 操作符</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ProtoAndChain/#理解-es6-class-构造以及继承的底层实现原理" class="sidebar-link">理解 es6 class 构造以及继承的底层实现原理</a></li></ul></li><li><a href="/web-self-examination/JavaScript/ScoprAndClosure/" class="sidebar-link">作用域与闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#理解词法作用域和动态作用域" class="sidebar-link">理解词法作用域和动态作用域</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#理解-javascript-的作用域和作用域链" class="sidebar-link">理解 JavaScript 的作用域和作用域链</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#理解-javascript-的执行上下文栈，可以应用堆栈信息快速定位问题" class="sidebar-link">理解 JavaScript 的执行上下文栈，可以应用堆栈信息快速定位问题</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#this-的原理以及几种不同使用场景的取值" class="sidebar-link">this 的原理以及几种不同使用场景的取值</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#闭包的实现原理和作用，可以列举几个开发中闭包的实际应用" class="sidebar-link">闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#理解堆栈溢出和内存泄漏的原理，如何防止" class="sidebar-link">理解堆栈溢出和内存泄漏的原理，如何防止</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#如何处理循环的异步操作" class="sidebar-link">如何处理循环的异步操作</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ScoprAndClosure/#理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理" class="sidebar-link">理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</a></li></ul></li><li><a href="/web-self-examination/JavaScript/ExecutionMechanism/" class="sidebar-link">执行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#为何-try-里面放-return，finally-还会执行，理解其内部机制" class="sidebar-link">为何 try 里面放 return，finally 还会执行，理解其内部机制</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#javascript-如何实现异步编程，可以详细描述-eventloop-机制" class="sidebar-link">JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#宏任务和微任务分别有哪些" class="sidebar-link">宏任务和微任务分别有哪些</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法" class="sidebar-link">可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#使用-promise-实现串行" class="sidebar-link">使用 Promise 实现串行</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#node-与浏览器-eventloop-的差异" class="sidebar-link">Node 与浏览器 EventLoop 的差异</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/ExecutionMechanism/#如何在保证页面运行流畅的情况下处理海量数据" class="sidebar-link">如何在保证页面运行流畅的情况下处理海量数据</a></li></ul></li><li><a href="/web-self-examination/JavaScript/GrammarAndApi/" class="sidebar-link">语法和 API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#理解-ecmascript-和-javascript-的关系" class="sidebar-link">理解 ECMAScript 和 JavaScript 的关系</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#熟练运用-es5、es6-提供的语法规范，" class="sidebar-link">熟练运用 es5、es6 提供的语法规范，</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#熟练掌握-javascript-提供的全局对象（例如-date、math）、全局函数（例如-decodeuri、isnan）、全局属性（例如-infinity、undefined）" class="sidebar-link">熟练掌握 JavaScript 提供的全局对象（例如 Date、Math）、全局函数（例如 decodeURI、isNaN）、全局属性（例如 Infinity、undefined）</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#熟练应用-map、reduce、filter-等高阶函数解决问题" class="sidebar-link">熟练应用 map、reduce、filter 等高阶函数解决问题</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#setinterval-需要注意的点，使用-settimeout-实现-setinterval" class="sidebar-link">setInterval 需要注意的点，使用 settimeout 实现 setInterval</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#javascript-提供的正则表达式-api、可以使用正则表达式（邮箱校验、url-解析、去重等）解决常见问题" class="sidebar-link">JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL 解析、去重等）解决常见问题</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/JavaScript/GrammarAndApi/#javascript-异常处理的方式，统一的异常处理方案" class="sidebar-link">JavaScript 异常处理的方式，统一的异常处理方案</a></li></ul></li><li><a href="/web-self-examination/JavaScript/Promise/" class="sidebar-link">Promise的手动实现步骤以及理解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运行环境</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架和类库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webGL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>openLayer</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试宝典</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="变量和类型"><a href="#变量和类型" aria-hidden="true" class="header-anchor">#</a> 变量和类型</h1> <h2 id="js-规定了几种语言类型"><a href="#js-规定了几种语言类型" aria-hidden="true" class="header-anchor">#</a> js 规定了几种语言类型</h2> <div class="tip custom-block"><p>众所周知，JavaScript 是一门弱类型语言，不对变量进行类型强制，变量可以随时持有任何类型的值，所以在 JavaScript 中，类型对于我们开发人员来说可以理解为值的内部特征，类型定义了值的行为，以使其能够区别于其他值。
JavaScript 中共有七种内置数据类型，包括基本类型和对象类型。</p></div> <hr> <h3 id="基本类型"><a href="#基本类型" aria-hidden="true" class="header-anchor">#</a> 基本类型</h3> <p>基本类型分为以下六种：</p> <ul><li><code>Undefined(未定义)</code></li> <li><code>Null(空值)</code></li> <li><code>Boolean(布尔)</code></li> <li><code>String(字符串)</code></li> <li><code>Number(数字)</code></li> <li><code>Symbol (符号)</code> <br></li></ul> <p><code>string</code> 、 <code>number</code> 、 <code>boolean</code> 和 <code>symbol</code> 这四种类型统称为<strong>原始类型（Primitive）</strong>，表示不能再细分下去的基本类型； <code>symbol</code> 表示独一无二的值，通过 <code>Symbol</code> 函数调用生成，由于生成的 <code>symbol</code> 值为原始类型，所以 <code>Symbol</code> 函数不能使用 <code>new</code> 调用； <code>null</code> 和 <code>undefined</code> 通常被认为是特殊值，这两种类型的值唯一，就是其本身。</p> <hr> <h3 id="对象类型"><a href="#对象类型" aria-hidden="true" class="header-anchor">#</a> 对象类型</h3> <p>对象类型（ <code>object</code> ）也称引用类型，以此和 JavaScript 的基本类型区分开来。对象在逻辑上是属性的无序集合，是存放各种值的容器。对象值存储的是引用地址，所以和基本类型值不可变的特性不同，对象值是可变的。</p> <p>声明一个对象通常有以下几种方式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 字面量形式，推荐</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// new 调用</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 与 new 调用相同</span>
cosnt obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 空对象</span>
</code></pre></div><h3 id="包装对象"><a href="#包装对象" aria-hidden="true" class="header-anchor">#</a> 包装对象</h3> <p>我们知道对象拥有属性和方法。但比如字符串这种基本类型值不属于对象为什么还拥有属性和方法呢？实际上在引用字符串的属性或方法时，会通过调用 <code>new String()</code> 的方式转换成对象，该对象继承了字符串的方法来处理属性的引用，一旦引用结束，便会销毁这个临时对象，这就是包装对象的概念。
不仅仅只是字符串有包装对象的概念，数字和布尔值也有相对应的 <code>new Number()</code> 和 <code>new Boolean()</code> 包装对象。 <code>null</code> 和 <code>undefined</code> 没有包装对象，访问它们的属性会报类型错误。
字符串、数字和布尔值通过构造函数显式生成的包装对象，既然属于对象，和基本类型的值必然是有区别的，这点可以通过 t <code>ypeof</code> 检测出来。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token string">&quot;seymoe&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 'string'</span>
<span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;seymoe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'object'</span>
</code></pre></div><hr> <h2 id="js-对象的底层数据结构是什么"><a href="#js-对象的底层数据结构是什么" aria-hidden="true" class="header-anchor">#</a> js 对象的底层数据结构是什么</h2> <h3 id="概述-2"><a href="#概述-2" aria-hidden="true" class="header-anchor">#</a> 概述 2</h3> <p>需要阅读一些书籍解决，待解决</p> <hr> <h2 id="symbol-类型在实际开发中的应用"><a href="#symbol-类型在实际开发中的应用" aria-hidden="true" class="header-anchor">#</a> Symbol 类型在实际开发中的应用</h2> <h3 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h3> <div class="tip custom-block"><p>Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol</p></div> <h3 id="引入-symbol-原因"><a href="#引入-symbol-原因" aria-hidden="true" class="header-anchor">#</a> 引入 Symbol 原因</h3> <p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（ <code>mixin</code> 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 <code>Symbol</code> 的原因, 它是原始数据类型的一种，表示独一无二的值。</p> <h3 id="如何使用-symbol"><a href="#如何使用-symbol" aria-hidden="true" class="header-anchor">#</a> 如何使用 Symbol</h3> <ul><li><code>Symbol</code> 值通过 <code>Symbol</code> 函数生成。这就是说，对象的属性名现在可以有<strong>两种类型</strong>，一种是原来就有的字符串，另一种就是新增的 <code>Symbol</code> 类型。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> sl <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> s<span class="token punctuation">;</span> <span class="token comment">// string</span>

<span class="token keyword">typeof</span> sl<span class="token punctuation">;</span> <span class="token comment">// symbol</span>
</code></pre></div><p>上面代码表明， 变量 sl 是独一无二的值， <code>typeof</code> 运算符的结果，表明变量 <code>sl</code> 是 <code>Symbol</code> 数据类型，而不是字符串之类的其他类型。</p> <ul><li><code>Symbol</code> 函数可以接受一个字符串作为参数，表示对 <code>Symbol</code> 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li></ul> <hr> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1<span class="token punctuation">;</span> <span class="token comment">// Symbol(foo)</span>
s2<span class="token punctuation">;</span> <span class="token comment">// Symbol(bar)</span>

s1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Symbol(foo)&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Symbol(bar)&quot;</span>
</code></pre></div><hr> <ul><li><code>Symbol</code> 函数前不能使用 <code>new</code> 命令，否则会报错。这是因为生成的 <code>Symbol</code> 是一个原始类型的值，不是对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s <span class="token keyword">instanceof</span> <span class="token class-name">Symbol</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><hr> <ul><li>如果 <code>Symbol</code> 的参数是一个对象，就会调用该对象的 <code>toString</code> 方法，将其转为字符串，然后才生成一个 <code>Symbol</code> 值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
sym<span class="token punctuation">;</span> <span class="token comment">// Symbol(abc)</span>
</code></pre></div><hr> <ul><li>注意， <code>Symbol</code> 函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的 <code>Symbol</code> 函数的返回值是不相等的。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">/</span> 没有参数的情况
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1 <span class="token operator">===</span> s2 <span class="token comment">// false</span>

<span class="token comment">// 有参数的情况</span>
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1 <span class="token operator">===</span> s2 <span class="token comment">// false</span>
</code></pre></div><hr> <ul><li><code>Symbol</code> 值不能与其他类型的值进行运算，会报错。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;My symbol&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token string">&quot;your symbol is &quot;</span> <span class="token operator">+</span>
sym <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">your symbol is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>
    sym <span class="token comment">// TypeError: can't convert symbol to string</span>
  <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: can't convert symbol to string</span>
</code></pre></div><hr> <ul><li><code>Symbol</code> 值可以显式转为字符串, 也可以转为布尔值，但是<strong>不能转为数值</strong>。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Boolean</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token operator">!</span>sym<span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>sym<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">Number</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError</span>
sym <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// TypeError</span>
</code></pre></div><hr> <h3 id="作为属性名的-symbol"><a href="#作为属性名的-symbol" aria-hidden="true" class="header-anchor">#</a> 作为属性名的 Symbol</h3> <p>由于每一个 <code>Symbol</code> 值都是不相等的，这意味着 <code>Symbol</code> 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p> <ul><li>将对象的属性名指定为一个 Symbol 值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> mySymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 第一种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 第二种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">&quot;Hello!&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 第三种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mySymbol<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> <span class="token string">&quot;Hello!&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 以上写法都得到同样结果</span>
a<span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello!&quot;</span>
</code></pre></div><hr> <ul><li>注意， <code>Symbol</code> 值作为对象属性名时，不能用点运算符。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mySymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>mySymbol <span class="token operator">=</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
a<span class="token punctuation">[</span><span class="token string">&quot;mySymbol&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello!&quot;</span>
</code></pre></div><hr> <ul><li><code>Symbol</code> 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>log<span class="token punctuation">.</span>levels <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token constant">DEBUG</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;debug&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token constant">INFO</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token constant">WARN</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;warn&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">log</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>levels<span class="token punctuation">.</span><span class="token constant">DEBUG</span><span class="token punctuation">,</span> <span class="token string">&quot;debug message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">log</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>levels<span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">,</span> <span class="token string">&quot;info message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="symbol-实例，也就是作用-消除魔术字符串"><a href="#symbol-实例，也就是作用-消除魔术字符串" aria-hidden="true" class="header-anchor">#</a> Symbol 实例，也就是作用 消除魔术字符串</h3> <p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token parameter">shape<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> area <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&quot;Triangle&quot;</span><span class="token punctuation">:</span> <span class="token comment">// 魔术字符串</span>
      area <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> options<span class="token punctuation">.</span>width <span class="token operator">*</span> options<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token comment">/* ... more code ... */</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> area<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getArea</span><span class="token punctuation">(</span><span class="token string">&quot;Triangle&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
  height<span class="token punctuation">:</span> <span class="token number">100</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 魔术字符串</span>
</code></pre></div><p>上面代码中，字符串 Triangle 就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p> <p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p> <hr> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> shapeType <span class="token operator">=</span> <span class="token punctuation">{</span>
  triangle<span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token parameter">shape<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> area <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> shapeType<span class="token punctuation">.</span>triangle<span class="token punctuation">:</span>
      area <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> options<span class="token punctuation">.</span>width <span class="token operator">*</span> options<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> area<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getArea</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span>triangle<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
  height<span class="token punctuation">:</span> <span class="token number">100</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">COLOR_RED</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">COLOR_GREEN</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">getComplement</span><span class="token punctuation">(</span><span class="token parameter">color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">COLOR_RED</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token constant">COLOR_GREEN</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">COLOR_GREEN</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token constant">COLOR_RED</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Undefined color&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常量使用 <code>Symbol</code> 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的 switch 语句会按设计的方式工作。</p> <hr> <h3 id="symbol-作为属性名有哪些特性"><a href="#symbol-作为属性名有哪些特性" aria-hidden="true" class="header-anchor">#</a> Symbol 作为属性名有哪些特性</h3> <ul><li><code>Symbol</code> 作为属性名，该属性不会出现在 <code>for...in</code> 、 <code>for...of</code> 循环中，也不会被 <code>Object.keys()</code> 、 <code>Object.getOwnPropertyNames()</code> 、 <code>JSON.stringify()</code> 返回。但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名</li></ul> <p>`</p> <ul><li><code>Object.getOwnPropertySymbols</code> 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

obj<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
obj<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> objectSymbols <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

objectSymbols<span class="token punctuation">;</span>
<span class="token comment">// [Symbol(a), Symbol(b)]</span>
</code></pre></div><hr> <ul><li>下面是另一个例子， <code>Object.getOwnPropertySymbols</code> 方法与 <code>for...in</code> 循环、 <code>Object.getOwnPropertyNames</code> 方法进行对比的例子。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> foo<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> <span class="token string">&quot;foobar&quot;</span> <span class="token comment">// 定义一个对象，属性值为foobar</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无输出</span>
<span class="token punctuation">}</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// []</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [Symbol(foo)]</span>
</code></pre></div><hr> <ul><li>Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;my_key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token keyword">enum</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  nonEnum<span class="token punctuation">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span>
</code></pre></div><hr> <h3 id="汇总一些-symbol-方法和属性"><a href="#汇总一些-symbol-方法和属性" aria-hidden="true" class="header-anchor">#</a> 汇总一些 Symbol 方法和属性</h3> <div class="language-js extra-class"><pre class="language-js"><code>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点</span>

Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。</span>

Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>isConcatSpreadable<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>species<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>match<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>replace<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>search<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>split<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">;</span>

Symbol<span class="token punctuation">.</span>unscopables<span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="手动实现简单的-symbol"><a href="#手动实现简单的-symbol" aria-hidden="true" class="header-anchor">#</a> 手动实现简单的 Symbol</h3> <div class="tip custom-block"><p>当调用 Symbol 的时候，会采用以下步骤：</p> <ol><li><p>如果使用 new ，就报错</p></li> <li><p>如果 description 是 undefined，让 descString 为 undefined</p></li> <li><p>否则 让 descString 为 ToString(description)</p></li> <li><p>如果报错，就返回</p> <p>返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString
考虑到还需要定义一个 [[Description]] 属性，如果直接返回一个基本类型的值，是无法做到这一点的，所以最终还是返回一个对象。</p></li></ol></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> <span class="token function-variable function">SymbolPolyfill</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token parameter">description</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实现特性：Symbol 函数前不能使用 new 命令</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">SymbolPolyfill</span><span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Symbol is not a constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 实现特性：如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</span>
    <span class="token keyword">var</span> descString <span class="token operator">=</span>
      description <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token punctuation">:</span> <span class="token function">String</span><span class="token punctuation">(</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 没有继承任何原型方法，也就是说它的原型链没有上一层</span>
    <span class="token keyword">var</span> symbol <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>symbol<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      __Description__<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> descString<span class="token punctuation">,</span>
        writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        configurable<span class="token punctuation">:</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 实现特性，因为调用该方法，返回的是一个新对象，两个对象之间，只要引用不同，就不会相同</span>
    <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  root<span class="token punctuation">.</span>SymbolPolyfill <span class="token operator">=</span> SymbolPolyfill<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="参考"><a href="#参考" aria-hidden="true" class="header-anchor">#</a> 参考</h3> <p><a href="https://shengchangwei.github.io/es6/#docs/symbol" target="_blank" rel="noopener noreferrer">阮一峰-ECMAScript 6 入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://segmentfault.com/a/1190000015262174#articleHeader8" target="_blank" rel="noopener noreferrer">ES6 系列之模拟实现 Symbol 类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="变量在内存中的存储形式"><a href="#变量在内存中的存储形式" aria-hidden="true" class="header-anchor">#</a> 变量在内存中的存储形式</h2> <div class="tip custom-block"><p class="custom-block-title">的数据类型包括两种：</p> <ul><li><p>基本数据类型：String、Boolean、Number、undefined、null、Symbol</p></li> <li><p>引用数据类型（复杂数据类型）：Object</p></li></ul> <p>在内存中分为栈区（stack）和堆区（heap）, 基本数据类型存放在栈区，引用数据类型存放在堆区</p></div> <h3 id="基本数据类型："><a href="#基本数据类型：" aria-hidden="true" class="header-anchor">#</a> 基本数据类型：</h3> <ol><li>声明一个变量 a 的时候，会在栈里面开辟出一块新的内存空间，用来存放这个变量 a 的值</li> <li>当变量 a 储存的数值发生改变时，栈区里对应的那块内存里存的数据也会发生改变</li> <li>再声明一个变量 b,并把变量 a 赋值给变量 b，此时会在栈内开辟一个新空间用来储存变量 b。</li> <li>这时变量 a 和变量 b 对应栈内存中两个空间，修改其中一个不会影响到另一个。</li></ol> <img src="/web-self-examination/varandTypes/stack.png" alt="foo"> <h3 id="复杂数据类型"><a href="#复杂数据类型" aria-hidden="true" class="header-anchor">#</a> 复杂数据类型</h3> <ol><li>声明一个对象 <code>var obj1 = {name: 'sheng'}</code> , 此时会在堆中开辟一块空间存放 <code>obj1值{name: 'sheng'}</code></li> <li>在栈中开辟一个空间存放指向 obj1 值的指针,obj1 通过这个指针可以拿到堆中的值</li> <li>如果将 obj1 这个对象赋值给 obj2 时，此时其实赋值给 obj2 是栈中的指针，</li> <li>那么 obj1 和 obj2 通过相同的指针指向是同一个值，修改其中一个对象的值，会影响到另一个对象。</li> <li>如果对 obj1 重新赋值的话，那么这个对象会堆中的另一块区域，不会在与 obj2 共享同一块区域。</li></ol> <img src="/web-self-examination/varandTypes/heap.png" alt="foo"> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**************按值传递***********/</span>
<span class="token comment">//两个变量赋值时,总是将原变量中的值复制一个副本给对方</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//原始类型</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//复制a中的值给b</span>
<span class="token comment">// 5  5</span>
a<span class="token operator">--</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//5</span>

<span class="token comment">/**************引用类型***********/</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//引用类型,不能存在变量本地,只能存在地址</span>
<span class="token keyword">var</span> brr <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment">//复制a中的地址给b</span>
<span class="token comment">// 地址  地址</span>
arr<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//时这两个变量用同一地址指向同一个数值</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>brr<span class="token punctuation">.</span>lenght<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">///4</span>
</code></pre></div><hr> <h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" aria-hidden="true" class="header-anchor">#</a> null 和 undefined 的区别</h2> <p>null： <code>Null</code> 类型，代表“空值”，代表一个空对象指针，使用 <code>typeof</code> 运算得到 <code>“object”</code> ，所以你可以认为它是一个特殊的对象值。</p> <p>undefined： <code>Undefined</code> 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。</p> <p><code>null</code> 是 <code>javascript</code> 的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 <code>undefined</code> 却是 <code>javascript</code> 才有的。 <code>undefined</code> 是在 <code>ECMAScript</code> 第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为 undefined，没有实参的形参也是 <code>undefined</code> 。</p> <p>javaScript 权威指南： <code>null</code> 和 <code>undefined</code> 都表示“值的空缺”，你可以认为 <code>undefined</code> 是表示系统级的、出乎意料的或类似错误的值的空缺，而 <code>null</code> 是表示程序级的、正常的或在意料之中的值的空缺。</p> <p>哈哈哈！！是不是感觉不是在说人话。如果和我一样不是很能听懂，请看下面。</p> <p>javaScript 高级程序设计： 在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 <code>undefined</code> 。 <code>null</code> 值则是表示空对象指针。</p> <p>最后，我的理解就是： <code>undefined</code> 是访问一个未初始化的变量时返回的值，而 <code>null</code> 是访问一个尚未存在的对象时所返回的值。因此，可以把 <code>undefined</code> 看作是空的变量，而 <code>null</code> 看作是空的对象。</p> <p>在定义一个想保存对象的变量时，就可以让该变量先保存 null 值，这样既能体现 null 是一个空指针对象，也能更好的区分 null 和 undefined。
<code>undefine</code> 是未定义的对象
<code>null</code> 是定义的对象 但是没有实例 ....
可以理解为 <code>null</code> 是 <code>defined</code> 了的 obj
只是没有赋值或 new</p> <hr> <h2 id="三种判断-javascript-数据类型的方式"><a href="#三种判断-javascript-数据类型的方式" aria-hidden="true" class="header-anchor">#</a> 三种判断 JavaScript 数据类型的方式</h2> <h3 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> typeOf</h3> <p><code>typeof</code> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种： <code>number、boolean、symbol、string、object、undefined、function</code> 等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// string 有效</span>
<span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// number 有效</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// symbol 有效</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//boolean 有效</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">//undefined 有效</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//object 无效</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//object 无效</span>
<span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function 有效</span>
<span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object 无效</span>
<span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object 无效</span>
</code></pre></div><p>有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：</p> <ul><li>对于基本类型，除 <code>null</code> 以外，均可以返回正确的结果。</li> <li>对于引用类型，除 <code>function</code> 以外，一律返回 <code>object</code> 类型。</li> <li>对于 <code>null</code> ，返回 <code>object</code> 类型。</li> <li>对于 <code>function</code> 返回 <code>function</code> 类型。</li> <li>其中， <code>null</code> 有属于自己的数据类型 <code>Null</code> ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 <code>Object</code> 类型，没有错，但不是我们想要的结果。</li></ul> <h3 id="instanceof"><a href="#instanceof" aria-hidden="true" class="header-anchor">#</a> instanceof</h3> <p><code>instanceof</code> 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true, 否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">instanceof</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token constant">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// A的内部属性 __proto__ 指向 B 的原型对象</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上述过程可以看出，当 A 的 <strong><code>__proto__</code></strong> 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">;</span>

<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">new</span> <span class="token class-name">Person</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>我们发现，虽然 instanceof 能够判断出 [ ] 是 Array 的实例，但它认为 [ ] 也是 Object 的实例，为什么呢？</p> <p>我们来分析一下 [ ]、Array、Object 三者之间的关系：</p> <p>从 instanceof 能够判断出 [ ]. <code>__proto__</code> 指向 Array.prototype，而 Array.prototype.<strong><code>_proto_</code></strong> 又指向了 Object.prototype，最终 Object.prototype.<strong><code>__proto__</code></strong> 指向了 null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：</p> <img src="/web-self-examination/varandTypes/proto_instaceof.jpg" alt="foo"> <p>从原型链可以看出，[] 的 <code>_porto_</code> 直接指向 <code>Array.prototype</code> ，间接指向 <code>Object.prototype</code> ，所以按照 <code>instanceof</code> 的判断规则，[] 就是 Object 的实例。依次类推，类似的 <code>new Date()</code> 、 <code>new Person()</code> 也会形成一条对应的原型链 。因此， <code>instanceof</code> <strong>只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p> <p><code>instanceof</code> 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;iframe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
xArray <span class="token operator">=</span> window<span class="token punctuation">.</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Array<span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">xArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>
arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>针对数组的这个问题，ES5 提供了 <code>Array.isArray()</code> 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//对数组执行某些操作</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Array.isArray()</code> 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。</p> <h3 id="constructor"><a href="#constructor" aria-hidden="true" class="header-anchor">#</a> constructor</h3> <ul><li><p>当一个函数 F 被定义时，JS 引擎会为 F 添加 <code>prototype</code> 原型，然后再在 <code>prototype</code> 上添加一个 <code>constructor</code> 属性，并让其指向 F 的引用。如下所示：</p> <img src="/web-self-examination/varandTypes/constructor1.png" alt="foo"></li> <li><p>当执行 var f = new F() 时，F 被当成了构造函数，f 是 F 的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 <code>f.constructor == F</code></p> <img src="/web-self-examination/varandTypes/constructor2.png" alt="foo"></li> <li><p>可以看出，F 利用原型对象上的 c <code>onstructor</code> 引用了自身，当 F 作为构造函数来创建对象时，原型上的 <code>constructor</code> 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p> <p>同样，JavaScript 中的内置对象在内部构建时也是这样做的：
<img src="/web-self-examination/varandTypes/constructor3.png" alt="foo"></p></li> <li><p>细节问题</p> <div class="tip custom-block"><ol><li><code>null</code> 和 <code>undefined</code> 是无效的对象，因此是不会有 <code>constructor</code> 存在的，这两种类型的数据需要通过其他方式来判断。</li> <li>函数的 <code>constructor</code> 是不稳定的，这个主要体现在自定义对象上，当开发者重写 <code>prototype</code> 后，原有的 <code>constructor</code> 引用会丢失， <code>constructor</code> 会默认为 Object</li></ol></div> <img src="/web-self-examination/varandTypes/constructor4.png" alt="foo"></li> <li><p>为什么变成了 Object？</p> <p>因为 <code>prototype</code> 被重新赋值的是一个 { }， { } 是 <code>new Object()</code> 的字面量，因此 <code>new</code> Object() 会将 <code>Object</code> 原型上的 <code>constructo</code> r 传递给 { }，也就是 <code>Object</code> 本身。
因此，为了规范开发，在重写对象原型时一般都需要重新给 <code>constructor</code> 赋值，以保证对象实例的类型不被篡改。</p></li></ul> <hr> <h2 id="出现小数精度丢失的原因"><a href="#出现小数精度丢失的原因" aria-hidden="true" class="header-anchor">#</a> 出现小数精度丢失的原因</h2> <p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926...，1.3333... 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。如图
<img src="/web-self-examination/varandTypes/jsNumber.png" alt="foo"></p> <p>意义</p> <ul><li>1 位用来表示符号位</li> <li>11 位用来表示指数</li> <li>52 位表示尾数</li></ul> <p>浮点数，比如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.1</span> <span class="token operator">&gt;&gt;</span> <span class="token number">0.0001</span> <span class="token number">1001</span> <span class="token number">1001</span> <span class="token number">1001</span>…（ <span class="token number">1001</span> 无限循环）
<span class="token number">0.2</span> <span class="token operator">&gt;&gt;</span> <span class="token number">0.0011</span> <span class="token number">0011</span> <span class="token number">0011</span> <span class="token number">0011</span>…（ <span class="token number">0011</span> 无限循环）
</code></pre></div><p>此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。</p> <p>大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。
大于 9007199254740992 的可能会丢失精度</p> <p>以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在“舍去”，精度丢失就发生了。</p> <h3 id="解决方案"><a href="#解决方案" aria-hidden="true" class="header-anchor">#</a> 解决方案</h3> <p>对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 <code>Math.pow(2, 53)</code> 就不会丢失精度。</p> <p>对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数），也就是说，尽量在业务中避免处理小数</p> <hr> <h2 id="可能发生隐式类型转换的场景以及转换原则"><a href="#可能发生隐式类型转换的场景以及转换原则" aria-hidden="true" class="header-anchor">#</a> 可能发生隐式类型转换的场景以及转换原则</h2> <ul><li><p>运算符的转换</p> <ol><li><code>-，\*，/，%</code> 会将操作数转换为数字去计算，但+不一样，两边纯数字会按数字相加，纯字符串会拼接，但数字和字符串也会将字符串和数字拼接起来。</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1 - '2'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 - '2'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//-1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1 * '2'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 * '2'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;6 / '4'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6 / '4'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">/</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1.5</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;6 % '4'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6 % '4'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">%</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
</code></pre></div><ul><li><p>双等号的隐式转换</p> <ol><li>双等号两边只要有以便是 NaN，便返回 false，且他自身不相等</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;NaN == 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN == 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;NaN == NaN&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;undefined == NaN&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>布尔值会转换为数字，false 转换为 0，true 转换为 1</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;0 == false&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0==false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1 == true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li>对象的转换</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[] == []&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [] == []</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[] == {}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [] == {}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;{} == {}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[] == ![]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [] ==![]</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token operator">!</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>对于前三个的原理是一样的，当两个值都是对象 (引用值) 时, 比较的是两个引用值在内存中是否是同一个对象. 因为此 [] 非彼 [], 然同为空数组, 确是两个互不相关的空数组, 所以为 false。
而最后一个是因为右边空数组会转化为 true，取反变为 false，false 变为 0；左边空数组变为空字符串再变为 0，0==0 就为 true。</p> <hr> <h2 id="理解值类型和引用类型"><a href="#理解值类型和引用类型" aria-hidden="true" class="header-anchor">#</a> 理解值类型和引用类型</h2> <ul><li><p>值类型：</p> <ol><li><p>占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）</p></li> <li><p>保存与复制的是值本身</p></li> <li><p>使用 <code>typeof</code> 检测数据的类型</p></li> <li><p>基本类型数据是值类型</p></li></ol></li> <li><p>引用类型：</p> <ol><li><p>占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）</p></li> <li><p>保存与复制的是指向对象的一个指针</p></li> <li><p>使用 <code>instanceof</code> 检测数据类型</p></li> <li><p>使用 new()方法构造出的对象是引用型</p></li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 值类型：Number、string、bollean、undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100 保存与复制的是值本身</span>

<span class="token comment">// 引用类型：对象、数组、函数、null(空指针)</span>
<span class="token comment">// 可以扩展属性</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">20</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span>

<span class="token comment">// 利用typeof来区分</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token keyword">typeof</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// boolean</span>
<span class="token comment">// typeof 区分不出来引用类型（除了函数）</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log<span class="token punctuation">;</span> <span class="token comment">//function</span>

<span class="token comment">// 用instanceof来区分引用类型</span>

<span class="token comment">// 如果变量是给定引用类型（根据它的原型链来识别）的实例，那么instanceof 操作符就会返回 true。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 变量 person 是 Object 吗？</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colors <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 变量 colors 是 Array 吗？</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 变量 pattern 是 RegExp 吗？</span>
</code></pre></div><ul><li>复制变量值: 如果从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> num1<span class="token punctuation">;</span>
</code></pre></div><p>上述例子中，num1 保存的值是 5，当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2 中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。
复制基本类型的过程：
<img src="/web-self-examination/varandTypes/copyNum.png" alt="foo"></p> <ul><li>复制引用类型: 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上引用同一个对象。因此，改变其中一个变量，就会影响另外一个变量：例</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><p>首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说，obj1 和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。
复制值类型的过程如下图：
<img src="/web-self-examination/varandTypes/copyObject.png" alt="foo"></p> <ul><li><p>参数传递(按值传递)</p> <p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
  obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setName</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><p>如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值为&quot;Greg&quot;的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是&quot;Nicholas&quot;。</p> <p>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/Gavin1997/vuepress_web.git/edit/master/docs/JavaScript/VarandTypes/readme.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">5/28/2020, 10:12:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/web-self-examination/JavaScript/ProtoAndChain/">
          原型和原型链
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/web-self-examination/assets/js/app.819c3246.js" defer></script><script src="/web-self-examination/assets/js/2.ee1b66a9.js" defer></script><script src="/web-self-examination/assets/js/30.55b5afbd.js" defer></script>
  </body>
</html>

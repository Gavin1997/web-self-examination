(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{268:function(v,_,a){"use strict";a.r(_);var i=a(38),t=Object(i.a)({},function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"开篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开篇","aria-hidden":"true"}},[v._v("#")]),v._v(" 开篇")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。")]),v._v(" "),a("p",[v._v("winter 在他的《重学前端》中提到：")]),v._v(" "),a("p",[v._v("到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。\n这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个 API 以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。")]),v._v(" "),a("p",[v._v("只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。")]),v._v(" "),a("p",[v._v("实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。")]),v._v(" "),a("p",[v._v("我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。")]),v._v(" "),a("p",[v._v("这不仅仅是我的知识体系，更是我时刻提醒自己的自检清单。")]),v._v(" "),a("p",[v._v("下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点，如果你有哪些我没归纳到的点，欢迎在评论区告诉我。")])]),v._v(" "),a("h1",{attrs:{id:"javascript-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-基础","aria-hidden":"true"}},[v._v("#")]),v._v(" JavaScript 基础")]),v._v(" "),a("p",[v._v("前端工程师吃饭的家伙，深度、广度一样都不能差。")]),v._v(" "),a("h2",{attrs:{id:"变量和类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量和类型","aria-hidden":"true"}},[v._v("#")]),v._v(" 变量和类型")]),v._v(" "),a("ol",[a("li",[v._v("JavaScript 规定了几种语言类型")]),v._v(" "),a("li",[v._v("JavaScript 对象的底层数据结构是什么")]),v._v(" "),a("li",[v._v("Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol")]),v._v(" "),a("li",[v._v("JavaScript 中的变量在内存中的具体存储形式")]),v._v(" "),a("li",[v._v("基本类型对应的内置对象，以及他们之间的装箱拆箱操作")]),v._v(" "),a("li",[v._v("理解值类型和引用类型")]),v._v(" "),a("li",[v._v("null 和 undefined 的区别")]),v._v(" "),a("li",[v._v("至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型")]),v._v(" "),a("li",[v._v("可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用")]),v._v(" "),a("li",[v._v("出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法")])]),v._v(" "),a("h2",{attrs:{id:"原型和原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链","aria-hidden":"true"}},[v._v("#")]),v._v(" 原型和原型链")]),v._v(" "),a("ol",[a("li",[v._v("理解原型设计模式以及 JavaScript 中的原型规则")]),v._v(" "),a("li",[v._v("instanceof 的底层实现原理，手动实现一个 instanceof")]),v._v(" "),a("li",[v._v("实现继承的几种方式以及他们的优缺点")]),v._v(" "),a("li",[v._v("至少说出一种开源项目(如 Node)中应用原型继承的案例")]),v._v(" "),a("li",[v._v("可以描述 new 一个对象的详细过程，手动实现一个 new 操作符")]),v._v(" "),a("li",[v._v("理解 es6 class 构造以及继承的底层实现原理")])]),v._v(" "),a("h2",{attrs:{id:"作用域和闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域和闭包","aria-hidden":"true"}},[v._v("#")]),v._v(" 作用域和闭包")]),v._v(" "),a("ol",[a("li",[v._v("理解词法作用域和动态作用域")]),v._v(" "),a("li",[v._v("理解 JavaScript 的作用域和作用域链")]),v._v(" "),a("li",[v._v("理解 JavaScript 的执行上下文栈，可以应用堆栈信息快速定位问题")]),v._v(" "),a("li",[v._v("this 的原理以及几种不同使用场景的取值")]),v._v(" "),a("li",[v._v("闭包的实现原理和作用，可以列举几个开发中闭包的实际应用")]),v._v(" "),a("li",[v._v("理解堆栈溢出和内存泄漏的原理，如何防止")]),v._v(" "),a("li",[v._v("如何处理循环的异步操作")]),v._v(" "),a("li",[v._v("理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理")])]),v._v(" "),a("h2",{attrs:{id:"执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行机制","aria-hidden":"true"}},[v._v("#")]),v._v(" 执行机制")]),v._v(" "),a("ol",[a("li",[v._v("为何 try 里面放 return，finally 还会执行，理解其内部机制")]),v._v(" "),a("li",[v._v("JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制")]),v._v(" "),a("li",[v._v("宏任务和微任务分别有哪些")]),v._v(" "),a("li",[v._v("可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法")]),v._v(" "),a("li",[v._v("使用 Promise 实现串行")]),v._v(" "),a("li",[v._v("Node 与浏览器 EventLoop 的差异")]),v._v(" "),a("li",[v._v("如何在保证页面运行流畅的情况下处理海量数据")])]),v._v(" "),a("h2",{attrs:{id:"语法和-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法和-api","aria-hidden":"true"}},[v._v("#")]),v._v(" 语法和 API")]),v._v(" "),a("ol",[a("li",[v._v("理解 ECMAScript 和 JavaScript 的关系")]),v._v(" "),a("li",[v._v("熟练运用 es5、es6 提供的语法规范，")]),v._v(" "),a("li",[v._v("熟练掌握 JavaScript 提供的全局对象（例如 Date、Math）、全局函数（例如 decodeURI、isNaN）、全局属性（例如 Infinity、undefined）")]),v._v(" "),a("li",[v._v("熟练应用 map、reduce、filter 等高阶函数解决问题")]),v._v(" "),a("li",[v._v("setInterval 需要注意的点，使用 settimeout 实现 setInterval")]),v._v(" "),a("li",[v._v("JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL 解析、去重等）解决常见问题")]),v._v(" "),a("li",[v._v("JavaScript 异常处理的方式，统一的异常处理方案")])]),v._v(" "),a("h1",{attrs:{id:"html-和-css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html-和-css","aria-hidden":"true"}},[v._v("#")]),v._v(" HTML 和 CSS")]),v._v(" "),a("h2",{attrs:{id:"html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html","aria-hidden":"true"}},[v._v("#")]),v._v(" HTML")]),v._v(" "),a("ol",[a("li",[v._v("从规范的角度理解 HTML，从分类和语义的角度使用标签")]),v._v(" "),a("li",[v._v("常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式")]),v._v(" "),a("li",[v._v("元信息类标签(head、title、meta)的使用目的和配置方法")]),v._v(" "),a("li",[v._v("HTML5 离线缓存原理")]),v._v(" "),a("li",[v._v("可以使用 Canvas API、SVG 等绘制高性能的动画")])]),v._v(" "),a("h2",{attrs:{id:"css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css","aria-hidden":"true"}},[v._v("#")]),v._v(" CSS")]),v._v(" "),a("ol",[a("li",[v._v("CSS 盒模型，在不同浏览器的差异")]),v._v(" "),a("li",[v._v("CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at 规则")]),v._v(" "),a("li",[v._v("CSS 伪类和伪元素有哪些，它们的区别和实际应用")]),v._v(" "),a("li",[v._v("HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理")]),v._v(" "),a("li",[v._v("水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点")]),v._v(" "),a("li",[v._v("BFC 实现原理，可以解决的问题，如何创建 BFC")]),v._v(" "),a("li",[v._v("可使用 CSS 函数复用代码，实现特殊效果")]),v._v(" "),a("li",[v._v("PostCSS、Sass、Less 的异同，以及使用配置，至少掌握一种")]),v._v(" "),a("li",[v._v("CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染")]),v._v(" "),a("li",[v._v("熟练使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等")]),v._v(" "),a("li",[v._v("CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况")]),v._v(" "),a("li",[v._v("掌握一套完整的响应式布局方案")])]),v._v(" "),a("h3",{attrs:{id:"手写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写","aria-hidden":"true"}},[v._v("#")]),v._v(" 手写")]),v._v(" "),a("ol",[a("li",[v._v("手写图片瀑布流效果")]),v._v(" "),a("li",[v._v("使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）")]),v._v(" "),a("li",[v._v("使用纯 CSS 实现曲线运动（贝塞尔曲线） 4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点")])]),v._v(" "),a("h1",{attrs:{id:"计算机基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机基础","aria-hidden":"true"}},[v._v("#")]),v._v(" 计算机基础")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。")])]),v._v(" "),a("h2",{attrs:{id:"编译原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译原理","aria-hidden":"true"}},[v._v("#")]),v._v(" 编译原理")]),v._v(" "),a("ol",[a("li",[v._v("理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序")]),v._v(" "),a("li",[v._v("正则表达式的匹配原理和性能优化")]),v._v(" "),a("li",[v._v("如何将 JavaScript 代码解析成抽象语法树(AST)")]),v._v(" "),a("li",[v._v("base64 的编码原理")]),v._v(" "),a("li",[v._v("几种进制的相互转换计算方法，在 JavaScript 中如何表示和转换")])]),v._v(" "),a("h2",{attrs:{id:"网络协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络协议","aria-hidden":"true"}},[v._v("#")]),v._v(" 网络协议")]),v._v(" "),a("ol",[a("li",[v._v("理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用")]),v._v(" "),a("li",[v._v("三次握手和四次挥手详细原理，为什么要使用这种机制")]),v._v(" "),a("li",[v._v("有哪些协议是可靠，TCP 有哪些手段保证可靠交付")]),v._v(" "),a("li",[v._v("DNS 的作用、DNS 解析的详细过程，DNS 优化原理")]),v._v(" "),a("li",[v._v("CDN 的作用和原理")]),v._v(" "),a("li",[v._v("HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么")]),v._v(" "),a("li",[v._v("HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题")]),v._v(" "),a("li",[v._v("HTTP1.1、HTTP2.0 带来的改变")]),v._v(" "),a("li",[v._v("HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求 10.理解 WebSocket 协议的底层原理、与 # HTTP 的区别")])]),v._v(" "),a("h2",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式","aria-hidden":"true"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),a("ol",[a("li",[v._v("熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等")]),v._v(" "),a("li",[v._v("发布订阅模式和观察者模式的异同以及实际应用")]),v._v(" "),a("li",[v._v("可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用")])]),v._v(" "),a("h1",{attrs:{id:"数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法","aria-hidden":"true"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！")])]),v._v(" "),a("h2",{attrs:{id:"javascript-编码能力"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-编码能力","aria-hidden":"true"}},[v._v("#")]),v._v(" JavaScript 编码能力")]),v._v(" "),a("ol",[a("li",[v._v("多种方式实现数组去重、扁平化、对比优缺点")]),v._v(" "),a("li",[v._v("多种方式实现深拷贝、对比优缺点")]),v._v(" "),a("li",[v._v("手写函数柯里化工具函数、并理解其应用场景和优势")]),v._v(" "),a("li",[v._v("手写防抖和节流工具函数、并理解其内部原理和应用场景")]),v._v(" "),a("li",[v._v("实现一个 sleep 函数")])]),v._v(" "),a("h2",{attrs:{id:"手动实现前端轮子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手动实现前端轮子","aria-hidden":"true"}},[v._v("#")]),v._v(" 手动实现前端轮子")]),v._v(" "),a("ol",[a("li",[v._v("手动实现 call、apply、bind")]),v._v(" "),a("li",[v._v("手动实现符合 Promise/A+规范的 Promise、手动实现 async await")]),v._v(" "),a("li",[v._v("手写一个 EventEmitter 实现事件发布、订阅")]),v._v(" "),a("li",[v._v("可以说出两种实现双向绑定的方案、可以手动实现")]),v._v(" "),a("li",[v._v("手写 JSON.stringify、JSON.parse")]),v._v(" "),a("li",[v._v("手写一个模版引擎，并能解释其中原理")]),v._v(" "),a("li",[v._v("手写懒加载、下拉刷新、上拉加载、预加载等效果")])]),v._v(" "),a("h2",{attrs:{id:"数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构","aria-hidden":"true"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),a("ol",[a("li",[v._v("理解常见数据结构的特点，以及他们在不同场景下使用的优缺点")]),v._v(" "),a("li",[v._v("理解数组、字符串的存储原理，并熟练应用他们解决问题")]),v._v(" "),a("li",[v._v("理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题")]),v._v(" "),a("li",[v._v("了解图、堆的基本结构和使用场景")])]),v._v(" "),a("h2",{attrs:{id:"算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法","aria-hidden":"true"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),a("ol",[a("li",[v._v("可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗")]),v._v(" "),a("li",[v._v("至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度")]),v._v(" "),a("li",[v._v("了解递归和循环的优缺点、应用场景、并可在开发中熟练应用")]),v._v(" "),a("li",[v._v("可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题")]),v._v(" "),a("li",[v._v("前端处理海量数据的算法方案")])]),v._v(" "),a("h1",{attrs:{id:"运行环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行环境","aria-hidden":"true"}},[v._v("#")]),v._v(" 运行环境")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("我们需要理清语言和环境的关系：\nECMAScript 描述了 JavaScript 语言的语法和基本对象规范\n浏览器作为 JavaScript 的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口")]),v._v(" "),a("p",[v._v("Node 也是 JavaScript 的一种运行环境，为它提供了操作 I/O、网络等 API")])]),v._v(" "),a("h2",{attrs:{id:"浏览器-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器-api","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器 API")]),v._v(" "),a("ol",[a("li",[v._v("浏览器提供的符合 W3C 标准的 DOM 操作 API、浏览器差异、兼容性")]),v._v(" "),a("li",[v._v("浏览器提供的浏览器对象模型 (BOM)提供的所有全局 API、浏览器差异、兼容性")]),v._v(" "),a("li",[v._v("大量 DOM 操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame 等)")]),v._v(" "),a("li",[v._v("浏览器海量数据存储、操作性能优化")]),v._v(" "),a("li",[v._v("DOM 事件流的具体实现机制、不同浏览器的差异、事件代理")]),v._v(" "),a("li",[v._v("前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、fetch、可以熟练使用第三方库")]),v._v(" "),a("li",[v._v("浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型")]),v._v(" "),a("li",[v._v("浏览器提供的几种存储机制、优缺点、开发中正确的选择")]),v._v(" "),a("li",[v._v("浏览器跨标签通信")])]),v._v(" "),a("h2",{attrs:{id:"浏览器原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器原理")]),v._v(" "),a("ol",[a("li",[v._v("各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分")]),v._v(" "),a("li",[v._v("请求数据到请求结束与服务器进行了几次交互")]),v._v(" "),a("li",[v._v("可详细描述浏览器从输入 URL 到页面展现的详细过程")]),v._v(" "),a("li",[v._v("浏览器解析 HTML 代码的原理，以及构建 DOM 树的流程")]),v._v(" "),a("li",[v._v("浏览器如何解析 CSS 规则，并将其应用到 DOM 树上")]),v._v(" "),a("li",[v._v("浏览器如何将解析好的带有样式的 DOM 树进行绘制")]),v._v(" "),a("li",[v._v("浏览器的运行机制，如何配置资源异步同步加载")]),v._v(" "),a("li",[v._v("浏览器回流与重绘的底层原理，引发原因，如何有效避免")]),v._v(" "),a("li",[v._v("浏览器的垃圾回收机制，如何避免内存泄漏")]),v._v(" "),a("li",[v._v("浏览器采用的缓存方案，如何选择和控制合适的缓存方案")])]),v._v(" "),a("h2",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node","aria-hidden":"true"}},[v._v("#")]),v._v(" Node")]),v._v(" "),a("ol",[a("li",[v._v("理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等 2. 掌握一种 Node 开发框架，如 Express，Express 和 Koa 的区别")]),v._v(" "),a("li",[v._v("熟练使用 Node 提供的 API 如 Path、Http、Child Process 等并理解其实现原理")]),v._v(" "),a("li",[v._v("Node 的底层运行原理、和浏览器的异同")]),v._v(" "),a("li",[v._v("Node 事件驱动、非阻塞机制的实现原理")])]),v._v(" "),a("p",[v._v("#框架和类库")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("轮子层出不穷，从原理上理解才是正道")])]),v._v(" "),a("h2",{attrs:{id:"typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript","aria-hidden":"true"}},[v._v("#")]),v._v(" TypeScript")]),v._v(" "),a("ol",[a("li",[v._v("理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现")]),v._v(" "),a("li",[v._v("理解使用 TypeScript 的好处，掌握 TypeScript 基础语法")]),v._v(" "),a("li",[v._v("TypeScript 的规则检测原理 4.可以在 React、Vue 等框架中使用 TypeScript 进行开发")])]),v._v(" "),a("h2",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react","aria-hidden":"true"}},[v._v("#")]),v._v(" React")]),v._v(" "),a("ol",[a("li",[v._v("React 和 vue 选型和优缺点、核心架构的区别")]),v._v(" "),a("li",[v._v("React 中 setState 的执行机制，如何有效的管理状态")]),v._v(" "),a("li",[v._v("React 的事件底层实现机制")]),v._v(" "),a("li",[v._v("React 的虚拟 DOM 和 Diff 算法的内部实现")]),v._v(" "),a("li",[v._v("React 的 Fiber 工作原理，解决了什么问题")]),v._v(" "),a("li",[v._v("React Router 和 Vue Router 的底层实现原理、动态加载实现原理 7.可熟练应用 React API、生命周期等，可应用 HOC、render props、Hooks 等高阶用法解决问题 8.基于 React 的特性和原理，可以手动实现一个简单的 React")])]),v._v(" "),a("h2",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),a("ol",[a("li",[v._v("熟练使用 Vue 的 API、生命周期、钩子函数")]),v._v(" "),a("li",[v._v("MVVM 框架设计理念")]),v._v(" "),a("li",[v._v("Vue 双向绑定实现原理、Diff 算法的内部实现")]),v._v(" "),a("li",[v._v("Vue 的事件机制 5.从 template 转换成真实 DOM 的实现机制")])]),v._v(" "),a("h2",{attrs:{id:"多端开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多端开发","aria-hidden":"true"}},[v._v("#")]),v._v(" 多端开发")]),v._v(" "),a("ol",[a("li",[v._v("单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA 的方案")]),v._v(" "),a("li",[v._v("理解 Viewport、em、rem 的原理和用法，分辨率、px、ppi、dpi、dp 的区别和实际应用")]),v._v(" "),a("li",[v._v("移动端页面适配解决方案、不同机型适配方案")]),v._v(" "),a("li",[v._v("掌握一种 JavaScript 移动客户端开发技术，如 React Native：可以搭建 React Native 开发环境，熟练进行开发，可理解 React Native 的运作原理，不同端适配")]),v._v(" "),a("li",[v._v("掌握一种 JavaScript PC 客户端开发技术，如 Electron：可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理")]),v._v(" "),a("li",[v._v("掌握一种小程序开发框架或原生小程序开发")]),v._v(" "),a("li",[v._v("理解多端框架的内部实现原理，至少了解一个多端框架的使用")])]),v._v(" "),a("h2",{attrs:{id:"数据流管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据流管理","aria-hidden":"true"}},[v._v("#")]),v._v(" 数据流管理")]),v._v(" "),a("ol",[a("li",[v._v("掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同")]),v._v(" "),a("li",[v._v("熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理")]),v._v(" "),a("li",[v._v("熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势")]),v._v(" "),a("li",[v._v("熟练使用 Vuex 管理数据流，并理解其实现原理")]),v._v(" "),a("li",[v._v("以上数据流方案的异同和优缺点，不情况下的技术选型")])]),v._v(" "),a("h2",{attrs:{id:"实用库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实用库","aria-hidden":"true"}},[v._v("#")]),v._v(" 实用库")]),v._v(" "),a("ol",[a("li",[v._v("至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现")]),v._v(" "),a("li",[v._v("掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表")]),v._v(" "),a("li",[v._v("掌握一种 GIS 开发框架，如百度地图 API")]),v._v(" "),a("li",[v._v("掌握一种可视化开发框架，如 Three.js、D3")]),v._v(" "),a("li",[v._v("工具函数库，如 lodash、underscore、moment 等，理解使用的工具类或工具函数的具体实现原理")])]),v._v(" "),a("h1",{attrs:{id:"开发和调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发和调试","aria-hidden":"true"}},[v._v("#")]),v._v(" 开发和调试")]),v._v(" "),a("ol",[a("li",[v._v("熟练使用各浏览器提供的调试工具")]),v._v(" "),a("li",[v._v("熟练使用一种代理工具实现请求代理、抓包，如 charls")]),v._v(" "),a("li",[v._v("可以使用 Android、IOS 模拟器进行调试，并掌握一种真机调试方案 4.了解 Vue、React 等框架调试工具的使用")])]),v._v(" "),a("h1",{attrs:{id:"前端工程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端工程","aria-hidden":"true"}},[v._v("#")]),v._v(" 前端工程")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度")])]),v._v(" "),a("h2",{attrs:{id:"项目构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目构建","aria-hidden":"true"}},[v._v("#")]),v._v(" 项目构建")]),v._v(" "),a("ol",[a("li",[v._v("理解 npm、yarn 依赖包管理的原理，两者的区别")]),v._v(" "),a("li",[v._v("可以使用 npm 运行自定义脚本")]),v._v(" "),a("li",[v._v("理解 Babel、ESLint、webpack 等工具在项目中承担的作用")]),v._v(" "),a("li",[v._v("ESLint 规则检测原理，常用的 ESLint 配置")]),v._v(" "),a("li",[v._v("Babel 的核心原理，可以自己编写一个 Babel 插件")]),v._v(" "),a("li",[v._v("可以配置一种前端代码兼容方案，如 Polyfill")]),v._v(" "),a("li",[v._v("Webpack 的编译原理、构建流程、热更新原理，chunk、bundle 和 module 的区别和应用")]),v._v(" "),a("li",[v._v("可熟练配置已有的 loaders 和 plugins 解决问题，可以自己编写 loaders 和 plugins")])]),v._v(" "),a("h2",{attrs:{id:"nginx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx","aria-hidden":"true"}},[v._v("#")]),v._v(" nginx")]),v._v(" "),a("ol",[a("li",[v._v("正向代理与反向代理的特点和实例")]),v._v(" "),a("li",[v._v("可手动搭建一个简单的 nginx 服务器、")]),v._v(" "),a("li",[v._v("熟练应用常用的 nginx 内置变量，掌握常用的匹配规则写法")]),v._v(" "),a("li",[v._v("可以用 nginx 实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理")])]),v._v(" "),a("h2",{attrs:{id:"开发提速"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发提速","aria-hidden":"true"}},[v._v("#")]),v._v(" 开发提速")]),v._v(" "),a("ol",[a("li",[v._v("熟练掌握一种接口管理、接口 mock 工具的使用，如 yapi")]),v._v(" "),a("li",[v._v("掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题")]),v._v(" "),a("li",[v._v("理解 TDD 与 BDD 模式，至少会使用一种前端单元测试框架")])]),v._v(" "),a("h2",{attrs:{id:"版本控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本控制","aria-hidden":"true"}},[v._v("#")]),v._v(" 版本控制")]),v._v(" "),a("ol",[a("li",[v._v("理解 Git 的核心原理、工作流程、和 SVN 的区别")]),v._v(" "),a("li",[v._v("熟练使用常规的 Git 命令、git rebase、git stash 等进阶命令")]),v._v(" "),a("li",[v._v("可以快速解决线上分支回滚、线上分支错误合并等复杂问题")])]),v._v(" "),a("h2",{attrs:{id:"持续集成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持续集成","aria-hidden":"true"}},[v._v("#")]),v._v(" 持续集成")]),v._v(" "),a("ol",[a("li",[v._v("理解 CI/CD 技术的意义，至少熟练掌握一种 CI/CD 工具的使用，如 Jenkins")]),v._v(" "),a("li",[v._v("可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web 应用、移动客户端应用、PC 客户端应用、小程序、H5 等等）")])]),v._v(" "),a("h1",{attrs:{id:"项目和业务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目和业务","aria-hidden":"true"}},[v._v("#")]),v._v(" 项目和业务")]),v._v(" "),a("h2",{attrs:{id:"后端技能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后端技能","aria-hidden":"true"}},[v._v("#")]),v._v(" 后端技能")]),v._v(" "),a("ol",[a("li",[v._v("了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言")]),v._v(" "),a("li",[v._v("掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库")])]),v._v(" "),a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化","aria-hidden":"true"}},[v._v("#")]),v._v(" 性能优化")]),v._v(" "),a("ol",[a("li",[v._v("了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案")]),v._v(" "),a("li",[v._v("了解常见的 Web、App 性能优化方案")]),v._v(" "),a("li",[v._v("SEO 排名规则、SEO 优化方案、前后端分离的 SEO")]),v._v(" "),a("li",[v._v("SSR 实现方案、优缺点、及其性能优化")]),v._v(" "),a("li",[v._v("Webpack 的性能优化方案")]),v._v(" "),a("li",[v._v("Canvas 性能优化方案")]),v._v(" "),a("li",[v._v("React、Vue 等框架使用性能优化方案")])]),v._v(" "),a("h2",{attrs:{id:"前端安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端安全","aria-hidden":"true"}},[v._v("#")]),v._v(" 前端安全")]),v._v(" "),a("ol",[a("li",[v._v("XSS 攻击的原理、分类、具体案例，前端如何防御")]),v._v(" "),a("li",[v._v("CSRF 攻击的原理、具体案例，前端如何防御")]),v._v(" "),a("li",[v._v("HTTP 劫持、页面劫持的原理、防御措施")])]),v._v(" "),a("h2",{attrs:{id:"业务相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#业务相关","aria-hidden":"true"}},[v._v("#")]),v._v(" 业务相关")]),v._v(" "),a("ol",[a("li",[v._v("能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题")]),v._v(" "),a("li",[v._v("能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题")]),v._v(" "),a("li",[v._v("可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性")])]),v._v(" "),a("h1",{attrs:{id:"学习提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#学习提升","aria-hidden":"true"}},[v._v("#")]),v._v(" 学习提升")]),v._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[v._v("vczh 大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：\n这十几年我一共做了三件事：")])]),v._v(" "),a("ol",[a("li",[v._v("不以赚钱为目的选择学习的内容；")]),v._v(" "),a("li",[v._v("以自己是否能造出轮子来衡量学习的效果；")]),v._v(" "),a("li",[v._v("坚持每天写自己的代码，前 10 年每天至少 6 个小时，不包含学习和工作的时间。\n上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。\n关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多")]),v._v(" "),a("li",[v._v("拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏")]),v._v(" "),a("li",[v._v("定期的将知识进行总结，不断完善自己的知识体系")]),v._v(" "),a("li",[v._v("尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用")]),v._v(" "),a("li",[v._v("坚持输出自己的代码，不要盲目的扎进公司业")])]),v._v(" "),a("h1",{attrs:{id:"技术之外"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#技术之外","aria-hidden":"true"}},[v._v("#")]),v._v(" 技术之外")]),v._v(" "),a("p",[v._v('这部分可能比上面九条加起来重要！ 1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS 等 2.了解互联网行业术语：B2B、B2C、C2C、O2O 等 3.掌握互联网行业沟通、问答、学习的 4.有一定的"PPT"能力 5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识 6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系')])])},[],!1,null,null,null);_.default=t.exports}}]);
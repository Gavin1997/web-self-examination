<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试宝典 | 前端自省清单</title>
    <meta name="description" content="全面、深入解析MDN推荐使用的JavaScript API">
    
    
    <link rel="preload" href="/web-self-examination/assets/css/0.styles.27befe48.css" as="style"><link rel="preload" href="/web-self-examination/assets/js/app.305dfcf6.js" as="script"><link rel="preload" href="/web-self-examination/assets/js/2.ee1b66a9.js" as="script"><link rel="preload" href="/web-self-examination/assets/js/46.2f2228bb.js" as="script"><link rel="prefetch" href="/web-self-examination/assets/js/10.094e6084.js"><link rel="prefetch" href="/web-self-examination/assets/js/11.b506eacb.js"><link rel="prefetch" href="/web-self-examination/assets/js/12.6d132e6e.js"><link rel="prefetch" href="/web-self-examination/assets/js/13.25ec3b04.js"><link rel="prefetch" href="/web-self-examination/assets/js/14.7f4ffd42.js"><link rel="prefetch" href="/web-self-examination/assets/js/15.14d5a2e8.js"><link rel="prefetch" href="/web-self-examination/assets/js/16.84b073a3.js"><link rel="prefetch" href="/web-self-examination/assets/js/17.f52a1d58.js"><link rel="prefetch" href="/web-self-examination/assets/js/18.3f0faa23.js"><link rel="prefetch" href="/web-self-examination/assets/js/19.f9bbe7bf.js"><link rel="prefetch" href="/web-self-examination/assets/js/20.7e6d7151.js"><link rel="prefetch" href="/web-self-examination/assets/js/21.10ac1404.js"><link rel="prefetch" href="/web-self-examination/assets/js/22.9b588e36.js"><link rel="prefetch" href="/web-self-examination/assets/js/23.545a32a6.js"><link rel="prefetch" href="/web-self-examination/assets/js/24.789a41bd.js"><link rel="prefetch" href="/web-self-examination/assets/js/25.27401a1d.js"><link rel="prefetch" href="/web-self-examination/assets/js/26.2c5e173e.js"><link rel="prefetch" href="/web-self-examination/assets/js/27.19f145c3.js"><link rel="prefetch" href="/web-self-examination/assets/js/28.5ded6bd1.js"><link rel="prefetch" href="/web-self-examination/assets/js/29.8c08d5f5.js"><link rel="prefetch" href="/web-self-examination/assets/js/3.f157ee41.js"><link rel="prefetch" href="/web-self-examination/assets/js/30.a53ac423.js"><link rel="prefetch" href="/web-self-examination/assets/js/31.f245e75c.js"><link rel="prefetch" href="/web-self-examination/assets/js/32.90ca4a03.js"><link rel="prefetch" href="/web-self-examination/assets/js/33.32a91ad3.js"><link rel="prefetch" href="/web-self-examination/assets/js/34.70f55b66.js"><link rel="prefetch" href="/web-self-examination/assets/js/35.d3031f3c.js"><link rel="prefetch" href="/web-self-examination/assets/js/36.f03138f0.js"><link rel="prefetch" href="/web-self-examination/assets/js/37.d6b9b395.js"><link rel="prefetch" href="/web-self-examination/assets/js/38.4c78b365.js"><link rel="prefetch" href="/web-self-examination/assets/js/39.56abfce0.js"><link rel="prefetch" href="/web-self-examination/assets/js/4.3547d142.js"><link rel="prefetch" href="/web-self-examination/assets/js/40.3a05dc43.js"><link rel="prefetch" href="/web-self-examination/assets/js/41.92508184.js"><link rel="prefetch" href="/web-self-examination/assets/js/42.a6ef9aa5.js"><link rel="prefetch" href="/web-self-examination/assets/js/43.a6b09ee4.js"><link rel="prefetch" href="/web-self-examination/assets/js/44.e5211d31.js"><link rel="prefetch" href="/web-self-examination/assets/js/45.13704b04.js"><link rel="prefetch" href="/web-self-examination/assets/js/47.edfe6799.js"><link rel="prefetch" href="/web-self-examination/assets/js/48.0a3f946d.js"><link rel="prefetch" href="/web-self-examination/assets/js/49.ae22168f.js"><link rel="prefetch" href="/web-self-examination/assets/js/5.bcbc336d.js"><link rel="prefetch" href="/web-self-examination/assets/js/50.b1764e52.js"><link rel="prefetch" href="/web-self-examination/assets/js/51.9e412e5b.js"><link rel="prefetch" href="/web-self-examination/assets/js/52.b2cdbf6a.js"><link rel="prefetch" href="/web-self-examination/assets/js/53.77670c70.js"><link rel="prefetch" href="/web-self-examination/assets/js/6.05fee451.js"><link rel="prefetch" href="/web-self-examination/assets/js/7.a3ade41e.js"><link rel="prefetch" href="/web-self-examination/assets/js/8.10eb3366.js"><link rel="prefetch" href="/web-self-examination/assets/js/9.e0ad901f.js">
    <link rel="stylesheet" href="/web-self-examination/assets/css/0.styles.27befe48.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/web-self-examination/" class="home-link router-link-active"><!----> <span class="site-name">前端自省清单</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web-self-examination/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/web-self-examination/HTML/" class="nav-link">HTML</a></div><div class="nav-item"><a href="/web-self-examination/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="http://www.gavin88.top:5800" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Gavin1997/vuepress_web.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web-self-examination/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/web-self-examination/HTML/" class="nav-link">HTML</a></div><div class="nav-item"><a href="/web-self-examination/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="http://www.gavin88.top:5800" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Gavin1997/vuepress_web.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运行环境</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架和类库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webGL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>openLayer</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试宝典</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web-self-examination/interForOther/" class="active sidebar-link">面试宝典</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#html" class="sidebar-link">HTML</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#css" class="sidebar-link">CSS</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#js" class="sidebar-link">JS</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#框架" class="sidebar-link">框架</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#工作流" class="sidebar-link">工作流</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#restapi请求" class="sidebar-link">restAPI请求</a></li><li class="sidebar-sub-header"><a href="/web-self-examination/interForOther/#工具的使用" class="sidebar-link">工具的使用</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面试宝典"><a href="#面试宝典" aria-hidden="true" class="header-anchor">#</a> 面试宝典</h1> <h2 id="html"><a href="#html" aria-hidden="true" class="header-anchor">#</a> HTML</h2> <h3 id="html5-有哪些新特性-移除了那些元素？如何处理-html5-新标签的浏览器兼容问题？如何区分-html-和-html5"><a href="#html5-有哪些新特性-移除了那些元素？如何处理-html5-新标签的浏览器兼容问题？如何区分-html-和-html5" aria-hidden="true" class="header-anchor">#</a> HTML5 有哪些新特性, 移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5</h3> <ol><li>canvas</li> <li>用于媒介回放的video和audio元素</li> <li>本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失; sessionStorage的数据在浏览器关闭后自动删除</li> <li>语意化更好的内容元素，比如 article footer header nav section</li> <li>位置API: Geolocation</li> <li>表单控件，calendar date time email url search</li> <li>新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket</li> <li>拖放API：drag、drop</li></ol> <h2 id="css"><a href="#css" aria-hidden="true" class="header-anchor">#</a> CSS</h2> <h3 id="什么是-flex-布局和-grid-布局？分别在什么时候使用"><a href="#什么是-flex-布局和-grid-布局？分别在什么时候使用" aria-hidden="true" class="header-anchor">#</a> 什么是 flex 布局和 grid 布局？分别在什么时候使用</h3> <p>Flex 布局和 grid 布局都是创建网页布局的好方法。但是，面试官想知道的是两者的主要区别：它们具有哪些功能和更强大灵活的功能？以及应该在何时使用？</p> <p>Flex 布局是 1D。这意味着使用 flex 布局可以操作行或列，但只能同时操作行和列中的任意一个。在 grid 布局中，您可以同时操作行和列。grid 布局功能非常强大，因为它具有许多强大而有用的特性，这些功能将有助于简化复杂布局的开发和控制。</p> <p>可以通过 grid 进行大方向的布局，使用 flex 进行具体内容的布局。</p> <h3 id="说明如何维护-css，假设您目前正在负责企业的实际项目"><a href="#说明如何维护-css，假设您目前正在负责企业的实际项目" aria-hidden="true" class="header-anchor">#</a> 说明如何维护 CSS，假设您目前正在负责企业的实际项目</h3> <p>管理大型项目中的 CSS 可能具有挑战性。一种方法是使用预处理器，例如 SASS 或 LESS。两者都是出色的预处理程序，可以很好地管理 CSS 文件。它们具有函数、变量、嵌套 CSS 等功能。这是避免样式表冲突以及管理大型 CSS 文件的有效方法。</p> <h3 id="rem-和-em-有什么区别"><a href="#rem-和-em-有什么区别" aria-hidden="true" class="header-anchor">#</a> rem 和 em 有什么区别</h3> <p>rem 和 em 都是 CSS 单位。rem 表示 root-em。em 和 rem 之间的区别是，rem 从根元素获取值，而 em 从父元素获取值。这是导致两者完全不同的原因。</p> <h3 id="position-fixed-和-sticky-之间的区别"><a href="#position-fixed-和-sticky-之间的区别" aria-hidden="true" class="header-anchor">#</a> position fixed 和 sticky 之间的区别</h3> <p>当开发人员要开发复杂的布局时，position是非常有趣的属性。我们很清楚什么是 fixed，它将把元素&quot;固定&quot;到我们声明的位置。sticky的基本作用类似于position：relative，直到元素滚动到特定偏移量以上为止，在这种情况下它将变成position：fixed，导致元素&quot;粘在&quot;其位置，而不是滚动到视线之外。</p> <h3 id="什么是-critical-css"><a href="#什么是-critical-css" aria-hidden="true" class="header-anchor">#</a> 什么是 critical CSS</h3> <p>Critical CSS 是一种提取首屏中 CSS 的技术，以便尽快将内容呈现给用户。这是快速加载网页首屏的好方法。
CSS 资源的加载情况对浏览器渲染页面的影响很大，这是因为默认情况下浏览器只有在完成 <code>&lt;head&gt;</code> 部分 CSS 样式的加载、解析之后才会渲染页面。这种渲染方式意味着，如果 CSS 文件很大，那么用户就必须等待很长的时间才能看到渲染结果。针对这一问题，我们将在接下来的内容中讨论一种非常规的解决方案，提高页面的渲染速度，这一方案常被称为 <code>critical rendering path</code> 。</p> <h3 id="什么是伪元素和伪类"><a href="#什么是伪元素和伪类" aria-hidden="true" class="header-anchor">#</a> 什么是伪元素和伪类</h3> <p>伪元素是样式元素特定部分的方式。例如 <code>::first-letter、:: first-line、:: after、:: before</code> 等。
伪类用于定义元素的特殊状态。例如 <code>:hover、:focus、:active</code> 等。
按照 CSS3 规范， <code>::</code> 和 <code>:</code> 用于区分伪元素和伪类。</p> <h3 id="介绍一下标准的css的盒子模型？低版本ie的盒子模型有什么不同的？"><a href="#介绍一下标准的css的盒子模型？低版本ie的盒子模型有什么不同的？" aria-hidden="true" class="header-anchor">#</a> 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3> <p>盒子模型有两种：IE 盒子模型(IE5.5及以下)，W3C标准盒子模型。</p> <p>盒子模型(box model)：
内容(content)、填充(padding)、边框(border)、边界(margin) 。</p> <p>不同：
W3C标准盒子模型的width和height，是content的宽高；
IE盒模型的width和height，是content、padding、border三部分合起来的宽高。
附加：
outline（轮廓）绘制在元素框之上，其不占据空间（不影响元素大小和定位）【所以如果轮廓线很粗，会遮住其他内容demo，不是很懂轮廓的覆盖顺序，它居然可以盖住下一个元素的内容？轮廓本身是另一次元的吗？会覆盖内容，但后一个轮廓会覆盖前一个轮廓】。
兼容性：IE8以上。</p> <h3 id="谈一谈css重绘与回流-重排"><a href="#谈一谈css重绘与回流-重排" aria-hidden="true" class="header-anchor">#</a> 谈一谈CSS重绘与回流/重排</h3> <p>会触发重绘或回流/重排的操作</p> <ol><li>添加、删除元素(回流+重绘)</li> <li>隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)</li> <li>移动元素，如改变top、left或移动元素到另外1个父元素中(重绘+回流)</li> <li>改变浏览器大小(回流+重绘)</li> <li>改变浏览器的字体大小(回流+重绘)</li> <li>改变元素的padding、border、margin(回流+重绘)</li> <li>改变浏览器的字体颜色（只重绘，不回流）</li> <li>改变元素的背景颜色（只重绘，不回流）</li></ol> <h4 id="需要怎么优化？"><a href="#需要怎么优化？" aria-hidden="true" class="header-anchor">#</a> 需要怎么优化？</h4> <ol><li>用transform 代替 top，left ，margin-top， margin-left... 这些位移属性</li> <li>opacity 加上 transform: translateZ/3d  这个属性之后便不会发生回流和重绘了</li> <li>不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之。</li> <li>如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置</li> <li>不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局</li> <li>对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签</li></ol> <h2 id="js"><a href="#js" aria-hidden="true" class="header-anchor">#</a> JS</h2> <h3 id="谈谈用户从输入url到页面渲染完成发生了什么过程"><a href="#谈谈用户从输入url到页面渲染完成发生了什么过程" aria-hidden="true" class="header-anchor">#</a> 谈谈用户从输入url到页面渲染完成发生了什么过程</h3> <ol><li>浏览器的地址栏输入URL并按下回车。</li> <li>浏览器查找当前URL的DNS缓存记录。</li> <li>DNS解析URL对应的IP。</li> <li>根据IP建立TCP连接（三次握手）。</li> <li>HTTP发起请求。</li> <li>服务器处理请求，浏览器接收HTTP响应。</li> <li>渲染页面，构建DOM树。</li> <li>关闭TCP连接（四次挥手）</li></ol> <h3 id="谈谈深拷贝和浅拷贝"><a href="#谈谈深拷贝和浅拷贝" aria-hidden="true" class="header-anchor">#</a> 谈谈深拷贝和浅拷贝</h3> <p>浅拷贝：浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。
深拷贝：深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。</p> <h3 id="dom事件模型-事件流"><a href="#dom事件模型-事件流" aria-hidden="true" class="header-anchor">#</a> DOM事件模型 事件流</h3> <p>事件模型分为：捕获和冒泡
事件流：
（1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段；
（2）目标阶段：真正的目标节点正在处理事件的阶段；
（3）冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。
事件委托（代理）
由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）
优点：</p> <ol><li>减少内存消耗，提高性能不需要为每一个子元素绑定事件</li> <li>动态绑定事件</li></ol> <h3 id="跨域是什么原因引起？怎么解决？"><a href="#跨域是什么原因引起？怎么解决？" aria-hidden="true" class="header-anchor">#</a> 跨域是什么原因引起？怎么解决？</h3> <p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p> <ol><li>jsonp函数</li></ol> <p>在HTML DOM中, script标签本身就可以访问其它域的资源，不受浏览器同源策略的限制，可以通过在页面动态创建script标签。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://aa.xx.com/js/*.js&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>iframe实现跨域</li></ol> <p>基于iframe实现的跨域要求两个域具有aa.xx.com, bb.xx.com这种特点，也就是两个页面必须属于同一个顶级基础域（例如都是xxx.com，或是xxx.com.cn），使用同一协议（例如都是 http）和同一端口（例如都是80），这样在两个页面中同时添加document.domain，就可以实现父页面调用子页面的函数</p> <ol start="3"><li>跨域资源共享（CORS）</li></ol> <p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p> <ol start="4"><li>使用HTML5的window.postMessage方法跨域</li></ol> <p>window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p> <ol start="5"><li>nginx反向代理</li></ol> <h3 id="谈谈你对闭包的理解"><a href="#谈谈你对闭包的理解" aria-hidden="true" class="header-anchor">#</a> 谈谈你对闭包的理解</h3> <p>函数声明的时候，会生成一个独立的作用域，同一作用域的对象可以互相访问，作用域呈层级包含状态，形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；另外子作用域会使用最近的父作用域的对象</p> <h3 id="谈谈原型链继承的理解"><a href="#谈谈原型链继承的理解" aria-hidden="true" class="header-anchor">#</a> 谈谈原型链继承的理解</h3> <p>什么是原型链：只要是对象就有原型, 并且原型也是对象, 因此只要定义了一个对象, 那么就可以找到他的原型, 如此反复, 就可以构成一个对象的序列, 这个结构就被称为原型链
所有的实例有一个内部指针(prototype)，指向它的原型对象，并且可以访问原型对象上的所有属性和方法。</p> <h3 id="说说构造函数中原型方法-静态方法-实列方法的区别"><a href="#说说构造函数中原型方法-静态方法-实列方法的区别" aria-hidden="true" class="header-anchor">#</a> 说说构造函数中原型方法, 静态方法, 实列方法的区别</h3> <p>简而言之，实例方法就是只有实例可以调用，静态方法只有构造函数可以调用，原型方法是实例和构造函数都可以调用，是共享的方法。</p> <p>像 Promise.all 和 Promise.race 这些就是静态方法，Promise.prototype.then 这些就是原型方法，new 出来的实例可以调用</p> <h3 id="谈谈tostring和string的区别？"><a href="#谈谈tostring和string的区别？" aria-hidden="true" class="header-anchor">#</a> 谈谈toString和String的区别？</h3> <p>toString()方法；数值、字符串、对象、布尔；都有toString方法；这个方法唯一能做的就是返回相应的字符串；其中null和undefined没有toString()方法；
String()属于强制转换， null转换的结果为null；undefined转换的结果为undefined；其余的如果有toString()方法，即调用该方法，返回相应的结果；</p> <h2 id="框架"><a href="#框架" aria-hidden="true" class="header-anchor">#</a> 框架</h2> <h3 id="mvvm和mvc的区别"><a href="#mvvm和mvc的区别" aria-hidden="true" class="header-anchor">#</a> MVVM和MVC的区别</h3> <p>MVC：MVC模式可以这样理解，将html看成view; js看成controller，处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）; 将js的ajax当做Model，从服务器获取数据，MVC是单向的。
MVVM：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变，MVVM是双向的。</p> <h3 id="route和-router的区别"><a href="#route和-router的区别" aria-hidden="true" class="header-anchor">#</a> $route和$router的区别</h3> <p>$router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。
$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息</p> <h3 id="vue中key的作用"><a href="#vue中key的作用" aria-hidden="true" class="header-anchor">#</a> vue中key的作用</h3> <p>强制替换元素，从而可以触发组件的生命周期钩子或者触发过渡。因为当key改变时，Vue认为一个新的元素产生了，从而会新插入一个元素来替换掉原有的元素。
<code>&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&lt;/span&gt; &lt;/transition&gt;</code> 、</p> <p>--这里如果text发生改变，整个 <code>&lt;span&gt;</code> 元素会发生更新，因为当text改变时，这个元素的key属性就发生了改变，在渲染更新时，Vue会认为这里新产生了一个元素，而老的元素由于key不存在了，所以会被删除，从而触发了过渡。
同理，key属性被用在组件上时，当key改变时会引起新组件的创建和原有组</p> <h3 id="vue中常用的修饰符"><a href="#vue中常用的修饰符" aria-hidden="true" class="header-anchor">#</a> vue中常用的修饰符</h3> <p>.stop              //组织单击事件冒泡
.prevent        //提交事件不再重新加载页面
.capture        //添加事件侦听器时使用事件捕获模式
.self              //只当事件在该元素本身时触发回调（在其子元素上不触发）
.once             //只触发一次事件</p> <h3 id="对keep-aerlive的了解"><a href="#对keep-aerlive的了解" aria-hidden="true" class="header-anchor">#</a> 对keep-aerlive的了解</h3> <p>通过设置了keep-alive，可以简单理解为从页面1跳转到页面2后，然后后退到页面1，只会加载缓存中之前已经渲染好的页面1，而不会再次重新加载页面1，及不会再触发页面一种的created等类似的钩子函数，除非自己重新刷新该页面1。</p> <h3 id="vuex中的成员？对应的作用"><a href="#vuex中的成员？对应的作用" aria-hidden="true" class="header-anchor">#</a> vuex中的成员？对应的作用</h3> <p>state =&gt; 基本数据
getters =&gt; 从基本数据派生的数据
mutations =&gt; 提交更改数据的方法，同步！
actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。
modules =&gt; 模块化Vuex</p> <h3 id="react-中-keys-的作用是什么？"><a href="#react-中-keys-的作用是什么？" aria-hidden="true" class="header-anchor">#</a> React 中 keys 的作用是什么？</h3> <p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p> <p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性</p> <h3 id="react-生命周期函数"><a href="#react-生命周期函数" aria-hidden="true" class="header-anchor">#</a> react 生命周期函数</h3> <ul><li><p>初始化阶段：</p> <ul><li>getDefaultProps: 获取实例的默认属性</li> <li>getInitialState: 获取每个实例的初始化状态</li> <li>componentWillMount：组件即将被装载、渲染到页面上</li> <li>render: 组件在这里生成虚拟的 DOM 节点</li> <li>componentDidMount: 组件真正在被装载之后</li></ul></li> <li><p>运行中状态：</p> <ul><li>componentWillReceiveProps: 组件将要接收到属性的时候调用</li> <li>shouldComponentUpdate: 组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</li> <li>componentWillUpdate: 组件即将更新不能修改属性和状态</li> <li>render: 组件重新描绘</li> <li>componentDidUpdate: 组件已经更新</li></ul></li> <li><p>销毁阶段：</p> <p>componentWillUnmount: 组件即将销毁</p></li></ul> <h3 id="shouldcomponentupdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldcomponentupdate-是做什么的，（react-性能优化是哪个周期函数？）" aria-hidden="true" class="header-anchor">#</a> shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h3> <p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p> <h3 id="为什么虚拟-dom-会提高性能"><a href="#为什么虚拟-dom-会提高性能" aria-hidden="true" class="header-anchor">#</a> 为什么虚拟 dom 会提高性能?</h3> <p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p> <p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p> <h3 id="react-diff-原理"><a href="#react-diff-原理" aria-hidden="true" class="header-anchor">#</a> react diff 原理</h3> <ul><li>把树形结构按照层级分解，只比较同级元素。</li> <li>给列表结构的每个单元添加唯一的 key 属性，方便比较。</li> <li>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</li> <li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li> <li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li></ul> <h2 id="工作流"><a href="#工作流" aria-hidden="true" class="header-anchor">#</a> 工作流</h2> <h3 id="谈谈前端性能优化"><a href="#谈谈前端性能优化" aria-hidden="true" class="header-anchor">#</a> 谈谈前端性能优化</h3> <ol><li>减少HTTP请求：合并文件、CSS精灵、inline Image</li> <li>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询</li> <li>避免重定向：多余的中间访问</li> <li>使Ajax可缓存</li> <li>非必须组件延迟加载,未来所需组件预加载</li> <li>减少DOM元素数量</li> <li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li> <li>减少iframe数量</li></ol> <h2 id="restapi请求"><a href="#restapi请求" aria-hidden="true" class="header-anchor">#</a> restAPI请求</h2> <h3 id="什么是-options-请求"><a href="#什么是-options-请求" aria-hidden="true" class="header-anchor">#</a> 什么是 options 请求</h3> <p>HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。
简单来说，就是可以用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法。</p> <p>在前端中我们一般不会主动发起这个请求，但是往往你可以看到浏览器中相同的请求发起了 2 次
其实，这是因为在跨域的情况下，在浏览器发起&quot;复杂请求&quot;时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p> <h4 id="简单请求与复杂请求"><a href="#简单请求与复杂请求" aria-hidden="true" class="header-anchor">#</a> 简单请求与复杂请求</h4> <p>某些请求不会触发 CORS 预检请求，这样的请求一般称为&quot;简单请求&quot;, 而会触发预检的请求则称为&quot;复杂请求&quot;。</p> <h5 id="简单请求"><a href="#简单请求" aria-hidden="true" class="header-anchor">#</a> 简单请求</h5> <ul><li>请求方法为GET、HEAD、POST时发的请求</li> <li>人为设置了规范集合之内的首部字段，如Accept/Accept-Language/Content-Language/- Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width</li> <li>Content-Type 的值仅限于下列三者之一, 即application/x-www-form-urlencoded、multipart/- form-data、text/plain</li> <li>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；</li> <li>请求中没有使用 ReadableStream 对象。</li></ul> <h6 id="复杂请求"><a href="#复杂请求" aria-hidden="true" class="header-anchor">#</a> 复杂请求</h6> <ul><li>使用了下面任一 HTTP 方法，PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH</li> <li>人为设置了以下集合之外首部字段，即简单请求外的字段</li> <li>Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul> <p><code>options 关键的请求字段</code></p> <p><strong>request header 的关键字段</strong></p> <table><thead><tr><th>关键字段</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td>Access-Control-Request-Method</td> <td style="text-align:center;">告知服务器，实际请求将使用 POST 方法</td></tr> <tr><td>Access-Control-Request-Headers</td> <td style="text-align:center;">告知服务器，实际请求将携带的自定义请求首部字段</td></tr></tbody></table> <p>如：
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type</p> <p><strong>response header 的关键字段</strong></p> <table><thead><tr><th>关键字段</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td>Access-Control-Allow-Methods</td> <td style="text-align:center;">表明服务器允许客户端使用什么方法发起请求</td></tr> <tr><td>Access-Control-Allow-Origin</td> <td style="text-align:center;">允许跨域请求的域名，如果要允许所有域名则设置为 *</td></tr> <tr><td>Access-Control-Request-Headers</td> <td style="text-align:center;">将实际请求所携带的首部字段告诉服务器</td></tr> <tr><td>Access-Control-Max-Age</td> <td style="text-align:center;">指定了预检请求的结果能够被缓存多久</td></tr></tbody></table> <h4 id="options-请求优化"><a href="#options-请求优化" aria-hidden="true" class="header-anchor">#</a> Options 请求优化</h4> <p>当我们发起跨域请求时，如果是简单请求，那么我们只会发出一次请求，但是如果是复杂请求则先发出 options 请求，用于确认目标资源是否支持跨域，然后浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。</p> <p>由此可见，当触发预检时，跨域请求便会发送 2 次请求，既增加了请求数，也延迟了请求真正发起的时间，严重影响性能。</p> <p>所以，我们可以优化 Options 请求，主要有 2 种方法。</p> <ol><li>转为简单请求，如用 JSONP 做跨域请求</li> <li>对 options 请求进行缓存，服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）</li></ol> <h4 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h4> <p>options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</p> <h3 id="get和post的区别"><a href="#get和post的区别" aria-hidden="true" class="header-anchor">#</a> get和POST的区别</h3> <p>get用来获取数据，post用来提交数据
get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。
get请求的数据会附加在url之 ，以 &quot; ？ &quot;分割url和传输数据，多个参数用 &quot;&amp;&quot;连接，而post请求会把请求的数据放在http请求体中。
get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。
get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中
首先get和post在本质上都是tcp链接，但由于http协议和浏览器或者服务器的限制，从而使它们在应用过程中产生了差别，但是它们中还有一个较大的区别：get在请求时发送一个数据包，会将header和data一起发送过去，而post会产生两个数据包先发送header，服务器返回100，然后在发送data，服务器返回200</p> <h2 id="工具的使用"><a href="#工具的使用" aria-hidden="true" class="header-anchor">#</a> 工具的使用</h2> <h4 id="webpack"><a href="#webpack" aria-hidden="true" class="header-anchor">#</a> webpack</h4> <h5 id="有哪些常见的loader？你用过哪些loader？"><a href="#有哪些常见的loader？你用过哪些loader？" aria-hidden="true" class="header-anchor">#</a> 有哪些常见的Loader？你用过哪些Loader？</h5> <pre><code>raw-loader：加载文件原始内容（utf-8）
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)
url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
source-map-loader：加载额外的 Source Map 文件，以方便断点调试
svg-inline-loader：将压缩后的 SVG 内容注入代码中
image-loader：加载并且压缩图片文件
json-loader 加载 JSON 文件（默认包含）
handlebars-loader: 将 Handlebars 模版编译成函数并返回
babel-loader：把 ES6 转换成 ES5
ts-loader: 将 TypeScript 转换成 JavaScript
awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader
sass-loader：将SCSS/SASS代码转换成CSS
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
eslint-loader：通过 ESLint 检查 JavaScript 代码
tslint-loader：通过 TSLint检查 TypeScript 代码
mocha-loader：加载 Mocha 测试用例的代码
coverjs-loader：计算测试的覆盖率
vue-loader：加载 Vue.js 单文件组件
i18n-loader: 国际化
cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里
</code></pre> <h5 id="有哪些常见的plugin？你用过哪些"><a href="#有哪些常见的plugin？你用过哪些" aria-hidden="true" class="header-anchor">#</a> 有哪些常见的Plugin？你用过哪些</h5> <pre><code>Plugindefine-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)
ignore-plugin：忽略部分文件
html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)
web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用
uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)
terser-webpack-plugin: 支持压缩 ES6 (Webpack4)
webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度
mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
serviceworker-webpack-plugin：为网页应用增加离线缓存功能
clean-webpack-plugin: 目录清理
ModuleConcatenationPlugin: 开启 Scope Hoisting
speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)
webpack-bundle-analyz
</code></pre></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/Gavin1997/vuepress_web.git/edit/master/docs/interForOther/readme.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">6/9/2020, 3:09:33 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/web-self-examination/Openlayers/投影Projections.html" class="prev">
          投影 Projections
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/web-self-examination/assets/js/app.305dfcf6.js" defer></script><script src="/web-self-examination/assets/js/2.ee1b66a9.js" defer></script><script src="/web-self-examination/assets/js/46.2f2228bb.js" defer></script>
  </body>
</html>
